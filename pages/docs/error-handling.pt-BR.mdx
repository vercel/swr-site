import { Callout } from 'nextra-theme-docs'
import Link from 'next/link'

# Manipula√ß√£o de Erros

Se um erro √© lan√ßado dentro de [`fetcher`](/docs/data-fetching), ele ser√° retornado como `error` pelo hook.

```js
const fetcher = url => fetch(url).then(r => r.json())

// ...
const { data, error } = useSWR('/api/user', fetcher)
```

O objeto `error` ser√° definido se a fetch promise for rejeitada.

## C√≥digo de Status e Objeto de Erro [#status-code-and-error-object]

As vezes queremos uma API para retornar um objeto de erro junto ao c√≥digo de status.
Ambos s√£o √∫teis para o cliente.

N√≥s podemos customizar nossa fun√ß√£o `fetcher` para retornar mais informa√ß√µes. Se o c√≥digo de status n√£o for `2xx`,
consideramos que √© um erro mesmo se ele puder ser lido como JSON:

```js
const fetcher = async url => {
  const res = await fetch(url)

  // Se o c√≥digo de status n√£o estiver no raio 200-299,
  // n√≥s ainda tentamos ler o JSON e retornar o objeto de erro
  if (!res.ok) {
    const error = new Error('An error occurred while fetching the data.')
    // Adicionar informa√ß√£o extra ao objeto de erro.
    error.info = await res.json()
    error.status = res.status
    throw error
  }

  return res.json()
}

// ...
const { data, error } = useSWR('/api/user', fetcher)
// error.info === {
//   message: "You are not authorized to access this resource.",
//   documentation_url: "..."
// }
// error.status === 403
```

<Callout emoji="üí°">
    Note que <code>data</code> e <code>error</code> podem existir ao mesmo tempo. Ent√£o a UI pode mostrar os dados existentes,
    enquanto sabe que o pr√≥ximo pedido falhou.
</Callout>

[Aqui](/examples/error-handling) n√≥s temos um exemplo.

## Retentativas [#error-retry]

SWR usa o [algoritmo de retentativa exponencial (em ingl√™s)](https://en.wikipedia.org/wiki/Exponential_backoff) para tentar novamente a requisi√ß√£o em caso de erro.
O algoritmo permite a aplica√ß√£o se recuperar rapidamente de erros, mas n√£o gasta muitos recursos tentando novamente muito frequentemente.

Voc√™ tamb√©m pode sobrescrever este comportamento atrav√©s da op√ß√£o [onErrorRetry](/docs/api#options):

```js
useSWR('/api/user', fetcher, {
  onErrorRetry: (error, key, config, revalidate, { retryCount }) => {
    // Nunca tentar ao 404.
    if (error.status === 404) return

    // Nunca tentar para uma chave espec√≠fica
    if (key === '/api/user') return

    // Tentar at√© 10 vezes.
    if (retryCount >= 10) return

    // Tentar novamente depois de 5 segundos
    setTimeout(() => revalidate({ retryCount }), 5000)
  }
})
```

Esse callback d√° a voc√™ a flexibilidade de tentar novamente baseado em v√°rias condi√ß√µes. Voc√™ tamb√©m pode desativ√°-lo definindo `shouldRetryOnError: false`.

Tamb√©m √© poss√≠vel prov√™-lo via contexto de [Configura√ß√£o Global](/docs/global-configuration).

## Relat√≥rio de Erros Globais [#global-error-report]

Voc√™ pode sempre obter o objeto de erro dentro do componente reativamente.
Mas, no caso de voc√™ querer lidar com o erro globalmente, para notificar a UI para mostrar um [toast](https://vercel.com/design/toast) ou [snackbar](https://material.io/components/snackbars), ou report√°-lo em algum lugar como [Sentry](https://sentry.io),
h√° um evento chamado [`onError`](/docs/api#options):

```jsx
<SWRConfig value={{
  onError: (error, key) => {
    if (error.status !== 403 && error.status !== 404) {
      // N√≥s podemos enviar o erro para Sentry,
      // ou mostrar uma notifica√ß√£o na interface.
    }
  }
}}>
  <MyApp />
</SWRConfig>
```
