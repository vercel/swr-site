import { Callout, Tabs, Tab } from 'nextra-theme-docs'
import Link from 'next/link'

# D√©marrage rapide

## Installation [#installation]

A l'int√©rieur de votre projet React, ex√©cutez la commande suivante :

<Tabs items={['pnpm', 'npm', 'yarn']}>
  <Tab>
    ```bash
    pnpm add swr
    ```
  </Tab>
  <Tab>
    ```bash
    npm i swr
    ```
  </Tab>
  <Tab>
    ```bash
    yarn add swr
    ```
  </Tab>
</Tabs>

## D√©marrage rapide [#quick-start]

Pour les API RESTful normales avec des donn√©es JSON, vous devez d'abord cr√©er une fonction `fetcher` qui n'est qu'un encapsuleur de la fonction native `fetch` :

```jsx
const fetcher = (...args) => fetch(...args).then(res => res.json())
```

<Callout emoji="üí°">
  Si vous souhaitez utiliser l'API GraphQL ou des librairies comme Axios, vous pouvez cr√©er votre propre fonction fetcher.
  Consultez [cet page](/docs/data-fetching) pour plus d'exemples.
</Callout>

Ensuite, vous pouvez importer `useSWR` et commencer √† l'utiliser dans n'importe quelle fonction composant :

```jsx
import useSWR from 'swr'

function Profile () {
  const { data, error, isLoading } = useSWR('/api/user/123', fetcher)

  if (error) return <div>√©chec du chargement</div>
  if (isLoading) return <div>chargement...</div>

  // rendu des donn√©es
  return <div>bonjour {data.name}!</div>
}
```

Normalement, il y a 3 √©tats possibles pour une requ√™te : "loading", "ready" ou "error". Vous pouvez utiliser la valeur de `data`, `error` et `isLoading` pour d√©terminer l'√©tat actuel de la requ√™te, et renvoyer l'interface utilisateur correspondante.

## R√©utilisation [#make-it-reusable]

Quand vous construisez une application web, vous pouvez avoir besoin de r√©utiliser les donn√©es √† plusieurs endroits de l'interface utilisateur. Il est incroyablement facile de cr√©er des hooks de donn√©es r√©utilisables au-dessus de SWR :

```jsx
function useUser (id) {
  const { data, error, isLoading } = useSWR(`/api/user/${id}`, fetcher)

  return {
    user: data,
    isLoading,
    isError: error
  }
}
```

Et l'utiliser dans vos composants :

```jsx
function Avatar ({ id }) {
  const { user, isLoading, isError } = useUser(id)

  if (isLoading) return <Spinner />
  if (isError) return <Error />
  return <img src={user.avatar} />
}
```

En utilisant ce motif, vous pouvez oublier la logique de **r√©cup√©ration de donn√©es** de mani√®re imp√©rative : d√©marrer la requ√™te, mettre √† jour l'√©tat de chargement, et renvoyer le r√©sultat final.
Au lieu de cela, votre code est plus d√©claratif : vous devez simplement sp√©cifier quelles donn√©es sont utilis√©es par le composant.

## Exemple [#example]

Avec un example r√©el, notre site web affiche une barre de navigation et du contenu, tous deux d√©pendent de `user` :

import { Welcome } from 'components/diagrams/welcome'

<div className="mt-8">
  <Welcome/>
</div>

D'habitude, on r√©cup√©re les donn√©es une fois en utilisant `useEffect` dans le composant primaire, et on passe les donn√©es aux composants enfants via les props (remarquez que nous ne g√©rons pas l'√©tat d'erreur pour le moment) :

```jsx {7-11,17,18,27}
// Composant Page

function Page () {
  const [user, setUser] = useState(null)

  // R√©cup√©ration des donn√©es
  useEffect(() => {
    fetch('/api/user')
      .then(res => res.json())
      .then(data => setUser(data))
  }, [])

  // Etat de chargement global
  if (!user) return <Spinner/>

  return <div>
    <Navbar user={user} />
    <Content user={user} />
  </div>
}

// Composants enfants

function Navbar ({ user }) {
  return <div>
    ...
    <Avatar user={user} />
  </div>
}

function Content ({ user }) {
  return <h1>Bon retour, {user.name}</h1>
}

function Avatar ({ user }) {
  return <img src={user.avatar} alt={user.name} />
}
```

Normalement, on doit garder toutes les donn√©es dans le composant primaire et ajouter des props √† chaque composant dans l'arborescence.
Le code devient plus difficile √† maintenir si on ajoute plus de donn√©es √† la page.

Bien que l'on puisse √©viter de passer les donn√©es via les props en utilisant [Context](https://reactjs.org/docs/context.html), il y a toujours le probl√®me du contenu dynamique :
Les composants √† l'int√©rieur des pages peuvent √™tre dynamiques, et le composant de niveau sup√©rieur ne sait peut-√™tre pas quelles donn√©es seront n√©cessaires par ses composants enfants.

SWR r√©sout parfaitement le probl√®me. Avec le hook `useUser` que nous venons de cr√©er, le code peut √™tre refactoris√© en :

```jsx {20,26}
// Composant Page

function Page () {
  return <div>
    <Navbar />
    <Content />
  </div>
}

// Composants enfants

function Navbar () {
  return <div>
    ...
    <Avatar />
  </div>
}

function Content () {
  const { user, isLoading } = useUser()
  if (isLoading) return <Spinner />
  return <h1>Bon retour, {user.name}</h1>
}

function Avatar () {
  const { user, isLoading } = useUser()
  if (isLoading) return <Spinner />
  return <img src={user.avatar} alt={user.name} />
}
```

Les donn√©es sont maintenant **li√©es** aux composants qui en ont besoin, et tous les composants sont **ind√©pendants** les uns des autres.
Tous les composants parents n'ont pas besoin de savoir quoi que ce soit sur les donn√©es ou de passer des donn√©es. Ils se contentent de les afficher.
Le code est beaucoup plus simple et plus facile √† maintenir maintenant.

Le plus beau, c'est qu'il n'y aura **qu'une seule requ√™te** envoy√©e √† l'API, car ils utilisent la m√™me cl√© SWR et la requ√™te est **d√©dupliqu√©e**, **mise en cache** et **partag√©e** automatiquement.

Aussi, l'application a maintenant la possibilit√© de r√©actualiser les donn√©es sur [le focus de l'utilisateur ou la reconnexion du r√©seau](/docs/revalidation) !
Cela signifie que lorsque l'ordinateur de l'utilisateur se r√©veille ou qu'il passe d'un onglet √† l'autre, les donn√©es seront automatiquement actualiser.
