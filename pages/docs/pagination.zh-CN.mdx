import Callout from 'nextra-theme-docs/callout'

# 分页

<Callout emoji="✅">
  请更新到最新版本 (≥ 0.3.0) 来用此 API。原来的 <code>useSWRPages</code> API 已废弃。
</Callout>

SWR 提供了一个专用 API `useSWRInfinite` 来支持常见的 UI 模式，比如 **分页** 和 **无限加载**。

## 何时应该继续使用 `useSWR`

### 分页

首先，我们可能 **并不** 需要 `useSWRInfinite`，如果我们正在构建如下内容，可以只使用 `useSWR`：

<div className="mt-8" />

<svg viewBox="0 0 769 356" fill="none">
<path d="M5 0.5H763C765.485 0.5 767.5 2.51472 767.5 5V351C767.5 353.485 765.485 355.5 763 355.5H5.00002C2.51473 355.5 0.5 353.485 0.5 351V5C0.5 2.51472 2.51472 0.5 5 0.5Z" fill="white" stroke="#EEEEEE"/>
<path d="M1 288H769" stroke="#E5E5E5"/>
<path d="M21 26H747V40H21V26Z" fill="#E5E5E5"/>
<path d="M21 70H747V84H21V70Z" fill="#E5E5E5"/>
<path d="M21 114H747V128H21V114Z" fill="#E5E5E5"/>
<path d="M21 158H747V172H21V158Z" fill="#E5E5E5"/>
<path d="M21 202H747V216H21V202Z" fill="#E5E5E5"/>
<path d="M21 246H747V260H21V246Z" fill="#E5E5E5"/>
<rect x="21.5" y="306.5" width="69" height="31" rx="2.5" fill="#FAFAFA" stroke="#D3D3D3"/>
<path d="M40.82 327.055L41.587 326.288L39.0259 323.736H45.7163V322.628H39.0259L41.587 320.067L40.82 319.308L36.9464 323.182L40.82 327.055ZM51.3455 327H52.6623V323.932H54.4521C56.4762 323.932 57.4776 322.709 57.4776 321.098C57.4776 319.491 56.4847 318.273 54.4563 318.273H51.3455V327ZM52.6623 322.815V319.402H54.3157C55.6197 319.402 56.1523 320.109 56.1523 321.098C56.1523 322.087 55.6197 322.815 54.3327 322.815H52.6623ZM58.919 327H60.1932V323.003C60.1932 322.146 60.8537 321.528 61.7571 321.528C62.0213 321.528 62.3196 321.575 62.4219 321.605V320.386C62.294 320.369 62.0426 320.357 61.8807 320.357C61.1136 320.357 60.4574 320.791 60.2188 321.494H60.1506V320.455H58.919V327ZM66.1112 327.132C67.5387 327.132 68.5487 326.429 68.8384 325.364L67.6325 325.146C67.4023 325.764 66.8484 326.08 66.1239 326.08C65.033 326.08 64.3001 325.372 64.266 324.111H68.9194V323.659C68.9194 321.294 67.5046 320.369 66.0217 320.369C64.1978 320.369 62.9961 321.759 62.9961 323.77C62.9961 325.803 64.1808 327.132 66.1112 327.132ZM64.2702 323.156C64.3214 322.227 64.9947 321.422 66.0302 321.422C67.0188 321.422 67.6665 322.155 67.6708 323.156H64.2702ZM75.8974 320.455H74.5295L72.8761 325.491H72.8079L71.1502 320.455H69.7823L72.1602 327H73.5238L75.8974 320.455Z" fill="#454545"/>
<rect x="307.5" y="306.5" width="69" height="31" rx="2.5" fill="#FAFAFA" stroke="#D3D3D3"/>
<path d="M329.225 318.273H327.922V324.682H327.841L323.4 318.273H322.181V327H323.498V320.599H323.579L328.015 327H329.225V318.273ZM333.865 327.132C335.293 327.132 336.303 326.429 336.592 325.364L335.386 325.146C335.156 325.764 334.602 326.08 333.878 326.08C332.787 326.08 332.054 325.372 332.02 324.111H336.673V323.659C336.673 321.294 335.259 320.369 333.776 320.369C331.952 320.369 330.75 321.759 330.75 323.77C330.75 325.803 331.935 327.132 333.865 327.132ZM332.024 323.156C332.075 322.227 332.749 321.422 333.784 321.422C334.773 321.422 335.42 322.155 335.425 323.156H332.024ZM338.94 320.455H337.543L339.554 323.727L337.517 327H338.915L340.385 324.554L341.859 327H343.253L341.195 323.727L343.236 320.455H341.842L340.385 323.003L338.94 320.455ZM347.599 320.455H346.257V318.886H344.983V320.455H344.024V321.477H344.983V325.342C344.979 326.531 345.886 327.107 346.892 327.085C347.297 327.081 347.57 327.004 347.719 326.949L347.489 325.896C347.403 325.913 347.246 325.952 347.041 325.952C346.628 325.952 346.257 325.815 346.257 325.078V321.477H347.599V320.455ZM357.724 327.055L361.598 323.182L357.724 319.308L356.957 320.075L359.518 322.628H352.828V323.736H359.518L356.957 326.293L357.724 327.055Z" fill="#454545"/>
<path d="M281.098 322.03C281.563 322.03 281.951 321.651 281.951 321.178C281.951 320.713 281.563 320.33 281.098 320.33C280.63 320.33 280.246 320.713 280.246 321.178C280.246 321.651 280.63 322.03 281.098 322.03ZM284.497 322.03C284.961 322.03 285.349 321.651 285.349 321.178C285.349 320.713 284.961 320.33 284.497 320.33C284.028 320.33 283.645 320.713 283.645 321.178C283.645 321.651 284.028 322.03 284.497 322.03ZM287.895 322.03C288.36 322.03 288.748 321.651 288.748 321.178C288.748 320.713 288.36 320.33 287.895 320.33C287.426 320.33 287.043 320.713 287.043 321.178C287.043 321.651 287.426 322.03 287.895 322.03Z" fill="black"/>
<rect x="103.5" y="306.5" width="44" height="31" rx="2.5" fill="#FAFAFA" stroke="#D3D3D3"/>
<path d="M126.653 318.273H125.37L123.193 319.696V320.957L125.281 319.594H125.332V327H126.653V318.273Z" fill="#454545"/>
<rect x="160.5" y="306.5" width="44" height="31" rx="2.5" fill="#EDEDED" stroke="#B3B3B3"/>
<path d="M179.498 327H185.242V325.871H181.313V325.807L183.048 323.991C184.646 322.376 185.102 321.605 185.102 320.629C185.102 319.227 183.96 318.153 182.315 318.153C180.683 318.153 179.489 319.21 179.489 320.804H180.746C180.742 319.866 181.347 319.253 182.289 319.253C183.175 319.253 183.849 319.798 183.849 320.668C183.849 321.439 183.389 321.993 182.451 322.986L179.498 326.045V327Z" fill="#454545"/>
<rect x="217.5" y="306.5" width="44" height="31" rx="2.5" fill="#FAFAFA" stroke="#D3D3D3"/>
<path d="M239.349 327.119C241.13 327.119 242.438 326.054 242.434 324.605C242.438 323.501 241.769 322.709 240.61 322.53V322.462C241.522 322.227 242.114 321.511 242.11 320.531C242.114 319.249 241.062 318.153 239.383 318.153C237.781 318.153 236.494 319.121 236.451 320.54H237.725C237.755 319.739 238.509 319.253 239.366 319.253C240.256 319.253 240.84 319.794 240.836 320.599C240.84 321.443 240.163 321.997 239.195 321.997H238.458V323.071H239.195C240.406 323.071 241.104 323.685 241.104 324.562C241.104 325.411 240.367 325.986 239.34 325.986C238.394 325.986 237.657 325.5 237.606 324.724H236.268C236.323 326.148 237.585 327.119 239.349 327.119Z" fill="#454545"/>
</svg>

...这是一个典型的分页 UI。我们来看看如何用 `useSWR` 轻松实现它：

```jsx highlight=5
function App () {
  const [pageIndex, setPageIndex] = useState(0);

  // API URL 包括页面索引，它是一个 React state。
  const { data } = useSWR(`/api/data?page=${pageIndex}`, fetcher);

  // ... 处理加载和错误状态

  return <div>
    {data.map(item => <div key={item.id}>{item.name}</div>)}
    <button onClick={() => setPageIndex(pageIndex - 1)}>Previous</button>
    <button onClick={() => setPageIndex(pageIndex + 1)}>Next</button>
  </div>
}
```

此外，我们可以为这个 "page 组件" 创建一个抽象：

```jsx highlight=13
function Page ({ index }) {
  const { data } = useSWR(`/api/data?page=${index}`, fetcher);

  // ... 处理加载和错误状态

  return data.map(item => <div key={item.id}>{item.name}</div>)
}

function App () {
  const [pageIndex, setPageIndex] = useState(0);

  return <div>
    <Page index={pageIndex}/>
    <button onClick={() => setPageIndex(pageIndex - 1)}>Previous</button>
    <button onClick={() => setPageIndex(pageIndex + 1)}>Next</button>
  </div>
}
```

SWR 的缓存会让我们在预先加载下一页方面受益匪浅。我们在一个 hidden 的 div 中渲染下一页，所以 SWR 将触发对下一页的数据请求。当用户导航到下一页时，数据已经加载好了：

```jsx highlight=6
function App () {
  const [pageIndex, setPageIndex] = useState(0);

  return <div>
    <Page index={pageIndex}/>
    <div style={{ display: 'none' }}><Page index={pageIndex + 1}/></div>
    <button onClick={() => setPageIndex(pageIndex - 1)}>Previous</button>
    <button onClick={() => setPageIndex(pageIndex + 1)}>Next</button>
  </div>
}
```

仅用一行代码，我们就获得了非常好的用户体验。`useSWR` hook 非常强大，它涵盖了大多数场景。

### 无限加载

有时我们想构建一个**无限加载** UI，用一个 "Load More" 按钮向列表追加数据（或者在滚动时自动完成）：

<div className="mt-8" />

<svg viewBox="0 0 769 356" fill="none">
<path d="M5 0.5H763C765.485 0.5 767.5 2.51472 767.5 5V351C767.5 353.485 765.485 355.5 763 355.5H5.00002C2.51473 355.5 0.5 353.485 0.5 351V5C0.5 2.51472 2.51472 0.5 5 0.5Z" fill="white" stroke="#EEEEEE"/>
<path d="M21 26H747V40H21V26Z" fill="#E5E5E5"/>
<path d="M21 70H747V84H21V70Z" fill="#E5E5E5"/>
<path d="M21 114H747V128H21V114Z" fill="#E5E5E5"/>
<path d="M21 158H747V172H21V158Z" fill="#E5E5E5"/>
<path d="M21 202H747V216H21V202Z" fill="#E5E5E5"/>
<path d="M21 246H747V260H21V246Z" fill="#E5E5E5"/>
<rect x="21.5" y="288.5" width="725" height="31" rx="2.5" fill="#FAFAFA" stroke="#D3D3D3"/>
<path d="M354.49 309H359.761V307.866H355.807V300.273H354.49V309ZM363.918 309.132C365.763 309.132 366.969 307.781 366.969 305.757C366.969 303.72 365.763 302.369 363.918 302.369C362.073 302.369 360.867 303.72 360.867 305.757C360.867 307.781 362.073 309.132 363.918 309.132ZM363.923 308.062C362.717 308.062 362.154 307.01 362.154 305.753C362.154 304.5 362.717 303.435 363.923 303.435C365.12 303.435 365.683 304.5 365.683 305.753C365.683 307.01 365.12 308.062 363.923 308.062ZM370.297 309.145C371.379 309.145 371.988 308.595 372.231 308.105H372.282V309H373.527V304.653C373.527 302.749 372.027 302.369 370.987 302.369C369.802 302.369 368.711 302.847 368.285 304.04L369.483 304.312C369.67 303.848 370.147 303.401 371.004 303.401C371.826 303.401 372.248 303.831 372.248 304.572V304.602C372.248 305.067 371.771 305.058 370.595 305.195C369.355 305.339 368.085 305.663 368.085 307.151C368.085 308.438 369.052 309.145 370.297 309.145ZM370.574 308.122C369.853 308.122 369.333 307.798 369.333 307.168C369.333 306.486 369.939 306.243 370.676 306.145C371.089 306.089 372.069 305.979 372.252 305.795V306.639C372.252 307.415 371.635 308.122 370.574 308.122ZM377.674 309.128C378.867 309.128 379.336 308.399 379.566 307.982H379.673V309H380.917V300.273H379.643V303.516H379.566C379.336 303.111 378.901 302.369 377.683 302.369C376.102 302.369 374.938 303.618 374.938 305.74C374.938 307.858 376.085 309.128 377.674 309.128ZM377.955 308.041C376.817 308.041 376.225 307.04 376.225 305.727C376.225 304.428 376.805 303.452 377.955 303.452C379.067 303.452 379.664 304.359 379.664 305.727C379.664 307.104 379.055 308.041 377.955 308.041ZM386.013 300.273V309H387.266V302.68H387.347L389.921 308.987H390.961L393.535 302.685H393.616V309H394.869V300.273H393.271L390.492 307.057H390.39L387.612 300.273H386.013ZM399.438 309.132C401.283 309.132 402.489 307.781 402.489 305.757C402.489 303.72 401.283 302.369 399.438 302.369C397.593 302.369 396.387 303.72 396.387 305.757C396.387 307.781 397.593 309.132 399.438 309.132ZM399.442 308.062C398.236 308.062 397.674 307.01 397.674 305.753C397.674 304.5 398.236 303.435 399.442 303.435C400.64 303.435 401.202 304.5 401.202 305.753C401.202 307.01 400.64 308.062 399.442 308.062ZM403.911 309H405.185V305.003C405.185 304.146 405.846 303.528 406.749 303.528C407.013 303.528 407.312 303.575 407.414 303.605V302.386C407.286 302.369 407.035 302.357 406.873 302.357C406.106 302.357 405.45 302.791 405.211 303.494H405.143V302.455H403.911V309ZM411.103 309.132C412.531 309.132 413.541 308.429 413.831 307.364L412.625 307.146C412.395 307.764 411.841 308.08 411.116 308.08C410.025 308.08 409.292 307.372 409.258 306.111H413.912V305.659C413.912 303.294 412.497 302.369 411.014 302.369C409.19 302.369 407.988 303.759 407.988 305.77C407.988 307.803 409.173 309.132 411.103 309.132ZM409.262 305.156C409.314 304.227 409.987 303.422 411.022 303.422C412.011 303.422 412.659 304.155 412.663 305.156H409.262Z" fill="#454545"/>
</svg>

要实现这一点，我们需要在这个页面 **动态生成请求数**。React Hooks 有 [2 个规则](https://reactjs.org/docs/hooks-rules.html)，所以我们 **不能** 写下面的代码：

```jsx highlight=5,6,7,8,9
function App () {
  const [cnt, setCnt] = useState(1)

  const list = []
  for (let i = 0; i < cnt; i++) {
    // 🚨 出错了！通常来说，你不能在循环里使用 hooks。
    const { data } = useSWR(`/api/data?page=${i}`)
    list.push(data)
  }

  return <div>
    {list.map((data, i) =>
      <div key={i}>{
        data.map(item => <div key={item.id}>{item.name}</div>)
      }</div>)}
    <button onClick={() => setCnt(cnt + 1)}>Load More</button>
  </div>
}
```

相反，我们可以使用创建的 `<Page />` 抽象来实现它：

```jsx highlight=5,6,7
function App () {
  const [cnt, setCnt] = useState(1)

  const pages = []
  for (let i = 0; i < cnt; i++) {
    pages.push(<Page index={i} key={i} />)
  }

  return <div>
    {pages}
    <button onClick={() => setCnt(cnt + 1)}>Load More</button>
  </div>
}
```

### 高级用例

但是，在某些高级用例中，上面的解决方案并不起作用。

比如，我们仍然实现相同的 "Load More" UI，但还需要显示一个 item 总数的数字。我们不能再使用 `<Page />` 这个解决方案了，因为顶级 UI (`<App />`) 需要每个页面的数据：

```jsx highlight=10
function App () {
  const [cnt, setCnt] = useState(1)

  const pages = []
  for (let i = 0; i < cnt; i++) {
    pages.push(<Page index={i} key={i} />)
  }

  return <div>
    <p>??? items</p>
    {pages}
    <button onClick={() => setCnt(cnt + 1)}>Load More</button>
  </div>
}
```

另外，如果分页 API 是 **基于游标的**，那么这个解决方案也不起作用。因为每个页面都需要上一页的数据，它们不是孤立的。

这就是这个新 `useSWRInfinite` Hook 的作用。

## useSWRInfinite

`useSWRInfinite` 让我们能够通过一个 Hook 触发多个请求。就像下面这样：

```jsx
const { data, error, isValidating, mutate, size, setSize } = useSWRInfinite(
  getKey, fetcher?, options?
)
```

和 `useSWR` 类似，这个新的 Hook 接受一个函数，该函数返回请求的 key、1 个 fetcher 函数和 options。它返回 `useSWR` 的所有返回值，还包括 2 个额外的值：page size 和 page size setter，类似一个 React state。

在无限加载中，一个 _页面_ 是一个请求，我们的目标是请求多页面并渲染它们。

### API

#### 参数

- `getKey`: 一个函数，接受索引和上一页数据，返回页面的 key
- `fetcher`: 和 `useSWR` 的 [fetcher 函数](/docs/data-fetching) 一样
- `options`: 接受 `useSWR` 支持的所有选项，以及 3 个额外选项：
  - `initialSize = 1`: 最初应加载的页面数量
  - `revalidateAll = false`: 始终尝试重新验证所有页面
  - `persistSize = false`: 当第一页的 key 发生变化时，不将 page size（或者 `initialSize` 如果设置了该参数）重置为 1

<Callout>
  请注意，`initialSize` 选项并不支持在渲染过程中发生改变。
</Callout>

#### 返回值

- `data`: 一个数组，每个页面请求的响应值
- `error`: 与 `useSWR` 的 `error` 返回值相同
- `isValidating`: 与 `useSWR` 的 `isValidating` 返回值相同
- `mutate`: 和 `useSWR` 的绑定 mutate 函数一样，但是操作 data 数组
- `size`: *即将*请求和返回的页面数
- `setSize`: 设置需要请求的页面数

### 示例 1：基于索引的分页 API

普通的基于索引的 API：

```
GET /users?page=0&limit=10
[
  { name: 'Alice', ... },
  { name: 'Bob', ... },
  { name: 'Cathy', ... },
  ...
]
```

```jsx highlight=4,5,6,7,10
// 一个函数，拿到每个页面的 key，
// `fetcher` 接受它的返回值。
// 如果返回是 `null`，该页面不会开始请求。
const getKey = (pageIndex, previousPageData) => {
  if (previousPageData && !previousPageData.length) return null // reached the end
  return `/users?page=${pageIndex}&limit=10`                    // SWR key
}

function App () {
  const { data, size, setSize } = useSWRInfinite(getKey, fetcher)
  if (!data) return 'loading'

  // 我们现在可以计算出所有用户的数量
  let totalUsers = 0
  for (let i = 0; i < data.length; i++) {
    totalUsers += data[i].length
  }

  return <div>
    <p>{totalUsers} users listed</p>
    {data.map((users, index) => {
      // `data` 是每个页面 API 响应的数组。
      return users.map(user => <div key={user.id}>{user.name}</div>)
    })}
    <button onClick={() => setSize(size + 1)}>Load More</button>
  </div>
}
```

`getKey` 函数是 `useSWRInfinite` 和 `useSWR` 之间的主要区别。它接受当前页的索引以及上一页的数据。因此可以很好地支持基于索引和基于游标的分页 API。

此外，`data` 不再只是一个 API 响应。它是多个 API 响应的数组：

```js
// `data` 将如下所示
[
  [
    { name: 'Alice', ... },
    { name: 'Bob', ... },
    { name: 'Cathy', ... },
    ...
  ],
  [
    { name: 'John', ... },
    { name: 'Paul', ... },
    { name: 'George', ... },
    ...
  ],
  ...
]
```

### 示例 2：基于游标或偏移的分页 API

假设现在 API 需要一个游标，并将下一个游标和数据一起返回：

```
GET /users?cursor=123&limit=10
{
  data: [
    { name: 'Alice' },
    { name: 'Bob' },
    { name: 'Cathy' },
    ...
  ],
  nextCursor: 456
}
```

我们可以将 `getKey` 函数改为下面这样：

```jsx
const getKey = (pageIndex, previousPageData) => {
  // reached the end
  if (previousPageData && !previousPageData.data) return null

  // 首页，没有 `previousPageData`
  if (pageIndex === 0) return `/users?limit=10`

  // 将游标添加到 API
  return `/users?cursor=${previousPageData.nextCursor}&limit=10`
}
```

### 高级特性

[这里有一个示例](/examples/infinite-loading) 演示如何使用 `useSWRInfinite` 实现以下功能：

- 加载状态
- 如果为空，显示一个特殊的 UI
- 如果 reached the end，禁用 "Load More" 按钮
- 数据源可变
- 刷新整个列表
