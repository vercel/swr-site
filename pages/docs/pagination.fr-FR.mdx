import { Callout } from 'nextra-theme-docs'
import { Pagination } from 'components/diagrams/pagination'
import { Infinite } from 'components/diagrams/infinite'

# Pagination

<Callout emoji="‚úÖ">
  Merci de mettre √† jour vers la derni√®re version (‚â• 0.3.0) pour utiliser cette API. L'ancienne API <code>useSWRPages</code> est maintenant obsol√®te.
</Callout>

SWR fournie une API d√©di√©e `useSWRInfinite` pour supporter les patterns UI courants comme la **pagination** et le **chargement infini**.

## Quand utiliser `useSWR` [#when-to-use-useswr]

### Pagination [#pagination]

Avant tout, on pourrait **NE PAS** avoir besoin de `useSWRInfinite` mais utiliser simplement `useSWR` si on construit quelque chose comme √ßa :

<div className="mt-8">
  <Pagination/>
</div>

...qui est une UI de pagination typique. Voyons comment on peut l'impl√©menter facilement avec `useSWR` :

```jsx {5}
function App () {
  const [pageIndex, setPageIndex] = useState(0);

  // L'URL de l'API inclut l'index de la page, qui est un √©tat React.
  const { data } = useSWR(`/api/data?page=${pageIndex}`, fetcher);

  // ... g√©rer les √©tats de chargement et d'erreur

  return <div>
    {data.map(item => <div key={item.id}>{item.name}</div>)}
    <button onClick={() => setPageIndex(pageIndex - 1)}>Pr√©c√©dent</button>
    <button onClick={() => setPageIndex(pageIndex + 1)}>Suivant</button>
  </div>
}
```

En outre, on peut cr√©er une abstraction pour ce "composant de page" :

```jsx {13}
function Page ({ index }) {
  const { data } = useSWR(`/api/data?page=${index}`, fetcher);

  // ... g√©rer les √©tats de chargement et d'erreur

  return data.map(item => <div key={item.id}>{item.name}</div>)
}

function App () {
  const [pageIndex, setPageIndex] = useState(0);

  return <div>
    <Page index={pageIndex}/>
    <button onClick={() => setPageIndex(pageIndex - 1)}>Pr√©c√©dent</button>
    <button onClick={() => setPageIndex(pageIndex + 1)}>Suivant</button>
  </div>
}
```

A cause du cache de SWR, on b√©n√©ficie du pr√©chargement de la page suivante. On rend la page suivante dans un div cach√©, donc SWR va d√©clencher le chargement de la page suivante. Quand l'utilisateur navigue vers la page suivante, les donn√©es sont d√©j√† l√† :

```jsx {6}
function App () {
  const [pageIndex, setPageIndex] = useState(0);

  return <div>
    <Page index={pageIndex}/>
    <div style={{ display: 'none' }}><Page index={pageIndex + 1}/></div>
    <button onClick={() => setPageIndex(pageIndex - 1)}>Pr√©c√©dent</button>
    <button onClick={() => setPageIndex(pageIndex + 1)}>Suivant</button>
  </div>
}
```

Avec seulement 1 ligne de code, on obtient une meilleure UX. Le hook `useSWR` est si puissant que la plupart des sc√©narios sont couverts par lui.

### Chargement infini [#infinite-loading]

Parfois, on veut construire une UI de **chargement infini**, avec un bouton "Charger plus" qui ajoute des donn√©es √† la liste (ou fait automatiquement quand on d√©file vers le bas) :

<div className="mt-8">
  <Infinite/>
</div>

Pour impl√©menter ceci, on a besoin de faire **un nombre dynamique de requ√™tes** sur cette page. Les hooks React ont [quelques r√®gles](https://reactjs.org/docs/hooks-rules.html), donc on **NE PEUT PAS** faire quelque chose comme √ßa :

```jsx {5,6,7,8,9}
function App () {
  const [cnt, setCnt] = useState(1)

  const list = []
  for (let i = 0; i < cnt; i++) {
    // üö® C'est faux ! En g√©n√©ral, on ne peut pas utiliser des hooks dans une boucle.
    const { data } = useSWR(`/api/data?page=${i}`)
    list.push(data)
  }

  return <div>
    {list.map((data, i) =>
      <div key={i}>{
        data.map(item => <div key={item.id}>{item.name}</div>)
      }</div>)}
    <button onClick={() => setCnt(cnt + 1)}>En r√©cup√©rer plus</button>
  </div>
}
```

Au lieu de √ßa, on peut utiliser l'abstraction `<Page />` qu'on a cr√©√© pour y arriver :

```jsx {5,6,7}
function App () {
  const [cnt, setCnt] = useState(1)

  const pages = []
  for (let i = 0; i < cnt; i++) {
    pages.push(<Page index={i} key={i} />)
  }

  return <div>
    {pages}
    <button onClick={() => setCnt(cnt + 1)}>En r√©cup√©rer plus</button>
  </div>
}
```

### Cas avanc√©s [#advanced-cases]

Cependant, dans certains cas avanc√©s, la solution ci-dessus ne fonctionne pas.

Par exemple, on impl√©mente toujours la m√™me UI "En r√©cup√©rer plus", mais on a aussi besoin d'afficher le nombre total d'√©l√©ments. On ne peut pas utiliser la solution `<Page />` parce que l'UI de niveau sup√©rieur (`<App />`) a besoin des donn√©es de chaque page :

```jsx {10}
function App () {
  const [cnt, setCnt] = useState(1)

  const pages = []
  for (let i = 0; i < cnt; i++) {
    pages.push(<Page index={i} key={i} />)
  }

  return <div>
    <p>??? √©l√©ments</p>
    {pages}
    <button onClick={() => setCnt(cnt + 1)}>En r√©cup√©rer plus</button>
  </div>
}
```

Aussi, si l'API de pagination est **bas√©e sur un curseur**, cette solution ne fonctionne pas non plus. Parce que chaque page a besoin des donn√©es de la page pr√©c√©dente, elles ne sont pas isol√©es.

C'est l√† que le nouveau hook `useSWRInfinite` peut aider.

## useSWRInfinite [#useswrinfinite]

`useSWRInfinite` bous donne la possibilit√© de d√©clencher un nombre de requ√™tes avec un seul hook. Voici √† quoi √ßa ressemble :

```jsx
import useSWRInfinite from 'swr/infinite'

// ...
const { data, error, isLoading, isValidating, mutate, size, setSize } = useSWRInfinite(
  getKey, fetcher?, options?
)
```

Semblable √† `useSWR`, ce nouveau hook accepte une fonction qui retourne la cl√© de la requ√™te, une fonction fetcher, et des options. Il retourne toutes les valeurs que `useSWR` retourne, incluant 2 valeurs suppl√©mentaires : la taille de la page et un setter de taille de page, comme un √©tat React.

Dans le chargement infini, une _page_ est une requ√™te, et notre but est de r√©cup√©rer plusieurs pages et de les afficher.

<Callout emoji="‚ö†Ô∏è">
  Si vous utilisez les versions SWR 0.x, `useSWRInfinite` doit √™tre import√© depuis `swr` :<br/>
  `import { useSWRInfinite } from 'swr'`
</Callout>

### API [#api]

#### Param√®tres [#parameters]

- `getKey`: une fonction qui accepte l'index et les donn√©es de la page pr√©c√©dente, et retourne la cl√© d'une page
- `fetcher`: identique √† la [fonction fetcher](/docs/data-fetching) de `useSWR`
- `options`: accepte toutes les options que `useSWR` supporte, avec 4 options suppl√©mentaires :
  - `initialSize = 1`: le nombre de pages qui doivent √™tre charg√©es initialement
  - `revalidateAll = false`: toujours essayer de revalider toutes les pages
  - `revalidateFirstPage = true`: toujours essayer de revalider la premi√®re page
  - `persistSize = false`: ne pas r√©initialiser la taille de la page √† 1 (ou `initialSize` si d√©fini) quand la cl√© de la premi√®re page change
  - `parallel = false`: r√©cup√®re plusieurs pages en parall√®le

<Callout>
  Notez que l'option `initialSize` n'est pas autoris√©e √† changer dans le cycle de vie.
</Callout>

#### Valeurs retourn√©es [#return-values]

- `data`: un tableau des valeurs de r√©ponse de chaque page
- `error`: identique √† `error` de `useSWR`
- `isLoading`: identique √† `isLoading` de `useSWR`
- `isValidating`: identique √† `isValidating` de `useSWR`
- `mutate`: identique √† la fonction `mutate` de `useSWR`, mais manipule le tableau de donn√©es
- `size`: le nombre de pages qui _seront_ r√©cup√©r√©es et retourn√©es
- `setSize`: d√©finit le nombre de pages qui doivent √™tre r√©cup√©r√©es

### Exemple 1: API pagin√©e bas√©e sur l'index [#example-1-index-based-paginated-api]

Pour une API bas√©e sur l'index normal :

```plaintext
GET /users?page=0&limit=10
[
  { name: 'Alice', ... },
  { name: 'Bob', ... },
  { name: 'Cathy', ... },
  ...
]
```

```jsx {4,5,6,7,10}
// Une fonction pour obtenir la cl√© SWR de chaque page,
// sa valeur de retour sera accept√©e par `fetcher`.
// Si `null` est retourn√©, la requ√™te de cette page ne d√©marrera pas.
const getKey = (pageIndex, previousPageData) => {
  if (previousPageData && !previousPageData.length) return null // atteint la fin
  return `/users?page=${pageIndex}&limit=10`                    // cl√© SWR
}

function App () {
  const { data, size, setSize } = useSWRInfinite(getKey, fetcher)
  if (!data) return 'loading'

  // On peut maintenant calculer le nombre total d'utilisateurs
  let totalUsers = 0
  for (let i = 0; i < data.length; i++) {
    totalUsers += data[i].length
  }

  return <div>
    <p>{totalUsers} utilisateurs trouv√©s</p>
    {data.map((users, index) => {
      // `data` est un tableau de la r√©ponse API de chaque page.
      return users.map(user => <div key={user.id}>{user.name}</div>)
    })}
    <button onClick={() => setSize(size + 1)}>En r√©cup√©rer plus</button>
  </div>
}
```

La fonction `getKey` est la diff√©rence majeure entre `useSWRInfinite` et `useSWR`.
Elle accepte l'index de la page courante, ainsi que les donn√©es de la page pr√©c√©dente.
Donc les API de pagination bas√©es sur l'index et le curseur peuvent √™tre support√©es facilement.

Aussi `data` n'est plus juste une r√©ponse API. C'est un tableau de plusieurs r√©ponses API :

```js
// `data` ressemblera √† √ßa
[
  [
    { name: 'Alice', ... },
    { name: 'Bob', ... },
    { name: 'Cathy', ... },
    ...
  ],
  [
    { name: 'John', ... },
    { name: 'Paul', ... },
    { name: 'George', ... },
    ...
  ],
  ...
]
```

### Exemple 2: API pagin√©e bas√©e sur le curseur [#example-2-cursor-based-paginated-api]

Disons que l'API demande un curseur et retourne le curseur suivant avec les donn√©es :

```plaintext
GET /users?cursor=123&limit=10
{
  data: [
    { name: 'Alice' },
    { name: 'Bob' },
    { name: 'Cathy' },
    ...
  ],
  nextCursor: 456
}
```

On peut changer la fonction `getKey` pour:

```jsx
const getKey = (pageIndex, previousPageData) => {
  // atteint la fin
  if (previousPageData && !previousPageData.data) return null

  // Premi√®re page, on n'a pas `previousPageData`
  if (pageIndex === 0) return `/users?limit=10`

  // ajout du curseur √† l'API
  return `/users?cursor=${previousPageData.nextCursor}&limit=10`
}
```

### Mode de r√©cup√©ration en parall√®le [#parallel-fetching-mode]

<Callout emoji="‚úÖ">
  Merci de mettre √† jour vers la derni√®re version (‚â• 2.1.0) pour utiliser cette API.
</Callout>

Le comportement par d√©faut de useSWRInfinite est de r√©cup√©rer les donn√©es pour chaque page en s√©quence, car la cr√©ation de la cl√© est bas√©e sur les donn√©es r√©cup√©r√©es pr√©c√©demment. Cependant, r√©cup√©rer les donn√©es s√©quentiellement pour un grand nombre de pages peut ne pas √™tre optimal, particuli√®rement si les pages ne sont pas interd√©pendantes. En sp√©cifiant l'option `parallel` √† `true` vous permettra de r√©cup√©rer les pages ind√©pendamment en parall√®le, ce qui peut acc√©l√©rer significativement le processus de chargement.

```jsx
// parallel = false (default)
// page1 ===> page2 ===> page3 ===> done
//
// parallel = true
// page1 ==> done
// page2 =====> done
// page3 ===> done
//
// previousPageData est toujours `null`
const getKey = (pageIndex, previousPageData) => {
  return `/users?page=${pageIndex}&limit=10`
}

function App () {
  const { data } = useSWRInfinite(getKey, fetcher, { parallel: true })
}
```

<Callout emoji="‚ö†Ô∏è">
    L'argument `previousPageData` de la fonction `getKey` devient `null` quand vous activez l'option `parallel`.
</Callout>

### Mutation Globale avec `useSWRInfinite` [#global-mutate-with-useswrinfinite]

`useSWRInfinite` stocke toutes les donn√©es de page dans le cache avec une cl√© de cache sp√©ciale avec chaque donn√©e de page, donc vous devez utiliser `unstable_serialize` dans `swr/infinite` pour revalider les donn√©es avec la mutation globale.

```jsx
import { useSWRConfig } from "swr"
import { unstable_serialize } from "swr/infinite"

function App() {
    const { mutate } = useSWRConfig()
    mutate(unstable_serialize(getKey))
}
```

<Callout emoji="‚ö†Ô∏è">
    Comme le nom l'implique, `unstable_serialize` n'est pas une API stable, donc nous pourrions la changer dans le futur.
</Callout>

### Fonctionnalit√©s avanc√©es [#advanced-features]

[Voici un exemple](/examples/infinite-loading) montrant comment vous pouvez impl√©menter les fonctionnalit√©s suivantes avec `useSWRInfinite` :

- √©tats de chargement
- afficher une UI sp√©ciale si c'est vide
- d√©sactiver le bouton "En r√©cup√©rer plus" si on atteint la fin
- source de donn√©es changeante
- rafra√Æchir la liste enti√®re
