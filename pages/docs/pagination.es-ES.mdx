import Callout from 'nextra-theme-docs/callout'

# Paginaci√≥n

<Callout emoji="‚úÖ">
  Por favor, actualice a la √∫ltima versi√≥n (‚â• 0.3.0) para utilizar esta API. La anterior API <code>useSWRPages</code> ha quedado obsoleta.
</Callout>

SWR proporciona una API dedicada `useSWRInfinite` para admitir patrones de UI comunes como la **paginaci√≥n** y la **carga infinita**.

## Cu√°ndo utilizar `useSWR`

### Paginaci√≥n

En primer lugar, es posible que **NO** necesitemos `useSWRInfinite`, sino que podemos utilizar simplemente `useSWR`
si estamos construyendo algo como esto:

import { Pagination } from 'components/diagrams/pagination'

<div className="mt-8">
  <Pagination/>
</div>

...que es un t√≠pico UI de paginaci√≥n. Veamos c√≥mo se puede implementar f√°cilmente con
`useSWR`:

```jsx {5}
function App () {
  const [pageIndex, setPageIndex] = useState(0);

  // La URL de la API incluye el √≠ndice de la p√°gina, que es un React state.
  const { data } = useSWR(`/api/data?page=${pageIndex}`, fetcher);

  // ... manejar los estados de carga y error

  return <div>
    {data.map(item => <div key={item.id}>{item.name}</div>)}
    <button onClick={() => setPageIndex(pageIndex - 1)}>Previous</button>
    <button onClick={() => setPageIndex(pageIndex + 1)}>Next</button>
  </div>
}
```

Adem√°s, podemos crear una abstracci√≥n para este "page component":

```jsx {13}
function Page ({ index }) {
  const { data } = useSWR(`/api/data?page=${index}`, fetcher);

  // ... manejar los estados de carga y error

  return data.map(item => <div key={item.id}>{item.name}</div>)
}

function App () {
  const [pageIndex, setPageIndex] = useState(0);

  return <div>
    <Page index={pageIndex}/>
    <button onClick={() => setPageIndex(pageIndex - 1)}>Previous</button>
    <button onClick={() => setPageIndex(pageIndex + 1)}>Next</button>
  </div>
}
```

Gracias a la cach√© de SWR, tenemos la ventaja de precargar la siguiente p√°gina.
La p√°gina siguiente se presenta dentro de un hidden div, por lo que SWR activar√° la obtenci√≥n de datos
de la p√°gina siguiente. Cuando el usuario navega a la siguiente p√°gina, los datos ya est√°n all√≠:

```jsx {6}
function App () {
  const [pageIndex, setPageIndex] = useState(0);

  return <div>
    <Page index={pageIndex}/>
    <div style={{ display: 'none' }}><Page index={pageIndex + 1}/></div>
    <button onClick={() => setPageIndex(pageIndex - 1)}>Previous</button>
    <button onClick={() => setPageIndex(pageIndex + 1)}>Next</button>
  </div>
}
```

Con s√≥lo 1 l√≠nea de c√≥digo, conseguimos una UX mucho mejor. El hook `useSWR` es tan potente,
que la mayor√≠a de los escenarios est√°n cubiertos por √©l.

### Carga infinita

A veces queremos construir una UI de **carga infinita**, con un bot√≥n "Load More" que a√±ada datos
a la lista (o que lo haga autom√°ticamente al desplazarse):

import { Infinite } from 'components/diagrams/infinite'

<div className="mt-8">
  <Infinite/>
</div>

Para implementar esto, necesitamos hacer **n√∫mero de peticiones din√°micas** en esta p√°gina. Los React Hooks tienen [un par de reglas](https://reactjs.org/docs/hooks-rules.html),
por lo que **NO PODEMOS** hacer algo as√≠:

```jsx {5,6,7,8,9}
function App () {
  const [cnt, setCnt] = useState(1)

  const list = []
  for (let i = 0; i < cnt; i++) {
    // üö® Esto es un error. Com√∫nmente, no se pueden usar hooks dentro de un bucle.
    const { data } = useSWR(`/api/data?page=${i}`)
    list.push(data)
  }

  return <div>
    {list.map((data, i) =>
      <div key={i}>{
        data.map(item => <div key={item.id}>{item.name}</div>)
      }</div>)}
    <button onClick={() => setCnt(cnt + 1)}>Load More</button>
  </div>
}
```

En su lugar, podemos utilizar la abstracci√≥n `<Page />` que hemos creado para conseguirlo:

```jsx {5,6,7}
function App () {
  const [cnt, setCnt] = useState(1)

  const pages = []
  for (let i = 0; i < cnt; i++) {
    pages.push(<Page index={i} key={i} />)
  }

  return <div>
    {pages}
    <button onClick={() => setCnt(cnt + 1)}>Load More</button>
  </div>
}
```

### Casos avanzados

Sin embargo, en algunos casos de uso avanzado, la soluci√≥n anterior no funciona.

Por ejemplo, seguimos implementando la misma UI "Load More", pero tambi√©n necesitamos mostrar un n√∫mero
sobre cu√°ntos item hay en total. No podemos utilizar la soluci√≥n `<Page />` porque
la UI de nivel superior (`<App />`) necesita los datos dentro de cada p√°gina:

```jsx {10}
function App () {
  const [cnt, setCnt] = useState(1)

  const pages = []
  for (let i = 0; i < cnt; i++) {
    pages.push(<Page index={i} key={i} />)
  }

  return <div>
    <p>??? items</p>
    {pages}
    <button onClick={() => setCnt(cnt + 1)}>Load More</button>
  </div>
}
```

Adem√°s, si la API de paginaci√≥n es **cursor based**, esa soluci√≥n tampoco funciona. Porque cada p√°gina
necesita los datos de la p√°gina anterior, no est√°n aisladas.

As√≠ es como este nuevo hook `useSWRInfinite` puede ayudar.

## useSWRInfinite

`useSWRInfinite` nos da la posibilidad de lanzar un n√∫mero de peticiones con un solo Hook. As√≠ es como se ve:

```jsx
import useSWRInfinite from 'swr/infinite'

// ...
const { data, error, isValidating, mutate, size, setSize } = useSWRInfinite(
  getKey, fetcher?, options?
)
```

Al igual que `useSWR`, este nuevo hook acepta una funci√≥n que devuelve la key de la solicitud, un fetcher funci√≥n y options.
Devuelve todos los valores que devuelve `useSWR`, incluyendo 2 valores extra: page size y page size setter, como un React state.

En la carga infinita, una _page_ es una petici√≥n, y nuestro objetivo es obtener varias p√°ginas y renderizarlas.

<Callout emoji="‚ö†Ô∏è">
  If you are using SWR 0.x versions, `useSWRInfinite` needs to be imported from `swr`:<br/>
  `import { useSWRInfinite } from 'swr'`
</Callout>

### API

#### Parametr√≥s

- `getKey`: una funci√≥n que acepta el √≠ndice y los datos de la p√°gina anterior, devuelve la key de una p√°gina
- `fetcher`: igual que la funci√≥n [fetcher](/docs/data-fetching) de `useSWR`
- `options`: acepta todas las opciones que soporta `useSWR`, con 3 opciones adicionales:
  - `initialSize = 1`: n√∫mero de p√°ginas que deben cargarse inicialmente
  - `revalidateAll = false`: intentar siempre revalidar todas las p√°ginas
  - `revalidateFirstPage = true`: always try to revalidate the first page
  - `persistSize = false`: no restablecer el page size a 1 (o `initialSize` si est√° establecido) cuando la key de la primera p√°gina cambia

<Callout>
    Tenga en cuenta que la opci√≥n `InitialSize` no puede cambiar en el ciclo de vida.
</Callout>

#### Valores de retorno

- `data`: una array de valores de respuesta fetch de cada p√°gina
- `error`: El mismo valor devuelto de `error` que `useSWR`
- `isValidating`: El mismo valor devuelto de `isValidating` que `useSWR`
- `mutate`: same as `useSWR`'s bound mutate function but manipulates the data array
- `size`: el n√∫mero de p√°ginas que _se obtendr√°n_ y devolver√°n
- `setSize`: establecer el n√∫mero de p√°ginas que deben ser recuperadas

### Ejemplo 1: API paginada basada en √≠ndices

Para las APIs normales basadas en √≠ndices:

```plaintext
GET /users?page=0&limit=10
[
  { name: 'Alice', ... },
  { name: 'Bob', ... },
  { name: 'Cathy', ... },
  ...
]
```

```jsx {4,5,6,7,10}
// Una funci√≥n para obtener la key de SWR de cada p√°gina,
// su valor de retorno ser√° aceptado por `fetcher`.
// Si se devuelve `null`, la petici√≥n de esa p√°gina no se iniciar√°.
const getKey = (pageIndex, previousPageData) => {
  if (previousPageData && !previousPageData.length) return null // reached the end
  return `/users?page=${pageIndex}&limit=10`                    // SWR key
}

function App () {
  const { data, size, setSize } = useSWRInfinite(getKey, fetcher)
  if (!data) return 'loading'

  // Ahora podemos calcular el n√∫mero de todos los usuarios
  let totalUsers = 0
  for (let i = 0; i < data.length; i++) {
    totalUsers += data[i].length
  }

  return <div>
    <p>{totalUsers} users listed</p>
    {data.map((users, index) => {
      // `data` es un array con la respuesta de la API de cada p√°gina.
      return users.map(user => <div key={user.id}>{user.name}</div>)
    })}
    <button onClick={() => setSize(size + 1)}>Load More</button>
  </div>
}
```

La funci√≥n `getKey` es la mayor diferencia entre `useSWRInfinite` y `useSWR`.
Acepta el √≠ndice de la p√°gina actual, as√≠ como los datos de la p√°gina anterior.
As√≠ que tanto la API de paginaci√≥n basada en el √≠ndice como la basada en el cursor pueden ser soportadas de forma adecuada.

Adem√°s, la `data` ya no son s√≥lo es una respuesta de la API. Es una array de m√∫ltiples respuestas de la API:

```js
// `data` tendr√° el siguiente aspecto
[
  [
    { name: 'Alice', ... },
    { name: 'Bob', ... },
    { name: 'Cathy', ... },
    ...
  ],
  [
    { name: 'John', ... },
    { name: 'Paul', ... },
    { name: 'George', ... },
    ...
  ],
  ...
]
```

### Ejemplo 2: Cursor or Offset Based Paginated API

Digamos que la API ahora requiere un cursor y devuelve el siguiente cursor junto con los datos:

```plaintext
GET /users?cursor=123&limit=10
{
  data: [
    { name: 'Alice' },
    { name: 'Bob' },
    { name: 'Cathy' },
    ...
  ],
  nextCursor: 456
}
```

Podemos cambiar nuestra funci√≥n `getKey` por:

```jsx
const getKey = (pageIndex, previousPageData) => {
  // reached the end
  if (previousPageData && !previousPageData.data) return null

  // la primera p√°gina, no tenemos `previousPageData`.
  if (pageIndex === 0) return `/users?limit=10`

  // a√±adir el cursor al punto final de la API
  return `/users?cursor=${previousPageData.nextCursor}&limit=10`
}
```

### Caracter√≠sticas avanzadas

[Aqu√≠ hay un ejemplo](/examples/infinite-loading) que muestra c√≥mo se pueden implementar las siguientes caracter√≠sticas con `useSWRInfinite`:

- estados de carga
- mostrar una UI especial si est√° vac√≠a
- desactivar el bot√≥n "Load More" si reached the end
- fuente de datos modificable
- actualizar toda la lista
