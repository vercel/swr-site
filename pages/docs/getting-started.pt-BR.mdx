import { Callout, Tabs, Tab } from 'nextra-theme-docs'
import Link from 'next/link'

# Comece a Usar

## Instala√ß√£o [#installation]

Dentro do diret√≥rio do seu projeto React, execute o seguinte:

<Tabs items={['pnpm', 'npm', 'yarn']}>
  <Tab>
    ```bash
    pnpm add swr
    ```
  </Tab>
  <Tab>
    ```bash
    npm i swr
    ```
  </Tab>
  <Tab>
    ```bash
    yarn add swr
    ```
  </Tab>
</Tabs>

## In√≠cio R√°pido [#quick-start]

Para APIs RESTful normais com dados JSON, primeiro voc√™ precisa criar uma fun√ß√£o `fetcher`, que √© apenas um wrapper do nativo `fetch`:

```jsx
const fetcher = (...args) => fetch(...args).then(res => res.json())
```

<Callout emoji="üí°">
    Se voc√™ quer usar APIs GraphQL ou outras bibliotecas como Axios, voc√™ pode criar sua pr√≥pria fun√ß√£o fetcher.
    Veja mais exemplos clicando <Link href="/docs/data-fetching">aqui</Link>.
</Callout>

Ent√£o voc√™ pode importar `useSWR` e come√ßar a us√°-lo em qualquer componente funcional:

```jsx
import useSWR from 'swr'

function Profile () {
  const { data, error, isLoading } = useSWR('/api/user/123', fetcher)

  if (error) return <div>falhou ao carregar</div>
  if (isLoading) return <div>carregando...</div>

  // renderizar dados
  return <div>ol√° {data.name}!</div>
}
```

Normalmente, existem 3 poss√≠veis estados de uma requisi√ß√£o: "loading", "ready", ou "error". Voc√™ pode usar o valor de `data`, `error` e `isLoading`
para determinar o estado atual da requisi√ß√£o, e retornar a interface correspondente.

## Torne-o Reutiliz√°vel [#make-it-reusable]

Quando construir uma aplica√ß√£o web, voc√™ pode precisar reutilizar os dados em v√°rios lugares da interface do usu√°rio. √â muito f√°cil criar
reutiliza√ß√µes de dados em cima do SWR:

```jsx
function useUser (id) {
  const { data, error, isLoading } = useSWR(`/api/user/${id}`, fetcher)

  return {
    user: data,
    isLoading,
    isError: error
  }
}
```

E us√°-lo em seus componentes:

```jsx
function Avatar ({ id }) {
  const { user, isLoading, isError } = useUser(id)

  if (isLoading) return <Spinner />
  if (isError) return <Error />
  return <img src={user.avatar} />
}
```

Adotando esse padr√£o, voc√™ pode esquecer sobre o **fetching** de dados no modo imperativo: inicie a requisi√ß√£o, atualize o estado de carregamento e retorne o resultado final.
Ao inv√©s, seu c√≥digo √© mais declarativo: voc√™ s√≥ precisa especificar o que dados √© usado pelo componente.

## Exemplo [#example]

Num exemplo real, o nosso site mostra uma barra de navega√ß√£o e o conte√∫do, ambos dependem de `user`:

import { Welcome } from 'components/diagrams/welcome'

<div className="mt-8">
  <Welcome/>
</div>

Tradicionalmente, n√≥s carregamos dados uma vez usando `useEffect` no componente principal, e passamos os dados para os componentes
filhos via props (note que n√≥s n√£o tratamos o estado de erro por agora).

```jsx {7-11,17,18,27}
// componente da p√°gina

function Page () {
  const [user, setUser] = useState(null)

  // obtendo os dados data
  useEffect(() => {
    fetch('/api/user')
      .then(res => res.json())
      .then(data => setUser(data))
  }, [])

  // estado de carregamento (loading) global
  if (!user) return <Spinner/>

  return <div>
    <Navbar user={user} />
    <Content user={user} />
  </div>
}

// componentes filho

function Navbar ({ user }) {
  return <div>
    ...
    <Avatar user={user} />
  </div>
}

function Content ({ user }) {
  return <h1>Bem vindo de volta, {user.name}</h1>
}

function Avatar ({ user }) {
  return <img src={user.avatar} alt={user.name} />
}
```

Normalmente, n√≥s precisamos manter todos os dados de carregamento no componente principal e adicionar props para todos os componentes.
O c√≥digo fica mais dif√≠cil de manter se adicionarmos mais depend√™ncias de dados √† p√°gina.

Apesar que possamos evitar passar props para componentes filhos, isto √©, usar [Context](https://reactjs.org/docs/context.html), ainda h√° o problema do conte√∫do din√¢mico:
componentes dentro da p√°gina podem ser din√¢micos, e o componente principal pode n√£o saber quais dados ser√£o necess√°rios por seus componentes filhos.

SWR resolve o problema perfeitamente. Com o hook `useUser`, o c√≥digo pode ser refatorado para:

```jsx {20,26}
// componente page

function Page () {
  return <div>
    <Navbar />
    <Content />
  </div>
}

// componentes filho

function Navbar () {
  return <div>
    ...
    <Avatar />
  </div>
}

function Content () {
  const { user, isLoading } = useUser()
  if (isLoading) return <Spinner />
  return <h1>Bem-vindo de volta, {user.name}</h1>
}

function Avatar () {
  const { user, isLoading } = useUser()
  if (isLoading) return <Spinner />
  return <img src={user.avatar} alt={user.name} />
}
```

Os dados agora est√£o **vinculados** aos componentes que precisam dos dados, e todos os componentes s√£o **independentes** uns dos outros.
Todos os componentes pai n√£o precisam saber nada sobre os dados ou transmitir dados. Eles apenas renderizam.
O c√≥digo √© muito mais simples e f√°cil de manter agora.

O mais bonito √© que haver√° apenas **1 solicita√ß√£o** enviada para a API, pois eles usam a mesma chave SWR e
a solicita√ß√£o √© **duplicada**, **armazenada em cache** e **compartilhada** automaticamente.

Al√©m disso, o aplicativo agora tem a capacidade de buscar novamente os dados ao [focar do usu√°rio ou reconex√£o de rede](/docs/revalidation)!
Isso significa que, quando o laptop do usu√°rio sair do modo de suspens√£o ou alternar entre as guias do navegador, os dados ser√£o atualizados automaticamente.
