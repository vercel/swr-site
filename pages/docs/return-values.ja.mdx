import Video from 'components/video'

# Return Values

```js
const { data, error, isLoading, isValidating, mutate } = useSWR(key, fetcher, options)
```

- `data`: data for the given key resolved by `fetcher` (or undefined if not loaded)
- `error`: error thrown by `fetcher` (or undefined)
- `isLoading`: if there's no data returned by the fetcher, not fallback or previous data
- `isValidating`: if there's a request or revalidation loading
- `mutate(data?, options?)`: function to mutate the cached data [(details)](/docs/mutation)

## The Patterns of the Return Values

This diagrams describe how SWR returns values in some scenarios.

### Fetch and Revalidate

These pattern is to fetch data and revalidate it later.

![A pattern for fetch and revalidate](/img/return-values/fetch-and-revalidate.svg)

### Key Change

This pattern is to fetch data and change the key and revalidate it later.

![A pattern for key change](/img/return-values/key-change.svg)

### Key Change + Previous Data

This pattern is to fetch data and change the key and revalidate it later with the `keepPreviousData` option.

![A pattern for key change + previous data](/img/return-values/key-change-previous-data.svg)

### Fallback

This pattern is to fetch data and revalidate it later with fallback data.

![A pattern for fallback](/img/return-values/fallback.svg)

### Key Change + Fallback

This pattern is to fetch data and change the key and revalidate it later with fallback data.

![A pattern for key change + fallback](/img/return-values/key-change-fallback.svg)

### Key Change + Previous Data + Fallback

This pattern is to fetch data and change the key and revalidate it later with the `keepPreviousData` option and fallback data.

![A pattern for key change + previous data + fallback](/img/return-values/key-change-previous-data-fallback.svg)

## Return previous data for better UX

When doing data fetching based on continuous user actions, e.g. real-time search when typing, keeping the previous fetched data can improve the UX a lot. `keepPreviousData` is an option to enable that behavior. Here's a simple search UI:

```jsx
function Search() {
  const [search, setSearch] = React.useState('');

  const { data, isLoading } = useSWR(`/search?q=${search}`, fetcher, {
    keepPreviousData: true
  });

  return (
    <div>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="Search..."
      />

      <div className={isLoading ? "loading" : ""}>
        {data?.products.map(item => <Product key={item.id} name={item.name} />)
      </div>
    </div>
  );
}
```

With `keepPreviousData` enabled, you will still get the previous data even if you change the SWR key and the data for the new key starts loading again.

<Video
  src="https://user-images.githubusercontent.com/3676859/163695903-a3eb1259-180e-41e0-821e-21c320201194.mp4"
  caption="Video: keep previous search results when keepPreviousData has been enabled"
  ratio={640/730}
/>

## Dependency Collection for performance

SWR only updates the states that are used by a component. If you only use `data` in the component, SWR ignores the updates of other properties like `isValidating`, and `isLoading`. This reduces rendering counts a lot. More information can be found [here](/docs/advanced/performance#dependency-collection).
