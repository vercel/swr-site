import { Callout } from 'nextra-theme-docs'

# Uso com Next.js

## Fetching de Dados Client-Side [#client-side-data-fetching]

Se sua p√°gina cont√©m dados que atualizam frequentemente, e voc√™ n√£o precisa pr√©-renderizar os dadoos, SWR √© uma excelente op√ß√£o e nenhuma configura√ß√£o especial √© necess√°ria: apenas importe `useSWR` e use o hook dentro de qualquer componente que use os dados.

√â assim que funciona:

- Primeiro, imediatamente mostre a p√°gina sem dados. Voc√™ pode mostrar estados de carregamento para dados ausentes.
- Depois, busque os dados no cliente e exiba quando estiver pronto.

Esse m√©todo funciona bem para p√°ginas de painel de usu√°rio, por exemplo. Porque um painel de usu√°rio √© um painel privado, especifico do usu√°rio, onde o SEO n√£o √© relevante e a p√°gina n√£o precisa ser pr√©-renderizada. Os dados s√£o frequentemente atualizados, que requerem o carregamento de dados no cliente.

## Pr√©-renderizando com Dados Padr√£o [#pre-rendering-with-default-data]

Se a p√°gina precisa ser pr√©-renderizada, Next.js suporta [2 formas de pr√©-renderizar](https://nextjs.org/docs/basic-features/data-fetching):
**Static Generation (SSG)** e **Server-side Rendering (SSR)**.

Junto com SWR, voc√™ pode pr√©-renderizar a p√°gina para SEO, e tamb√©m ter recursos como cache, revalidation, tracking de foco, refetching em intervalo no cliente.

Voc√™ pode usar a op√ß√£o `fallback` do [`SWRConfig`](/docs/global-configuration) para passar os dados pr√©-carregados como o valor inicial de todos os hooks SWR.
For exemplo o `getStaticProps`:

```jsx
 export async function getStaticProps () {
  // `getStaticProps` √© executado no lado do servidor
  const article = await getArticleFromAPI()
  return {
    props: {
      fallback: {
        '/api/article': article
      }
    }
  }
}

function Article() {
  // `data` sempre estar√° dispon√≠vel como `fallback`
  const { data } = useSWR('/api/article', fetcher)
  return <h1>{data.title}</h1>
}

export default function Page({ fallback }) {
  // hooks SWR dentro do limite do `SWRConfig` usar√£o esses valores.
  return (
    <SWRConfig value={{ fallback }}>
      <Article />
    </SWRConfig>
  )
}
```

A p√°gina continua sendo pr√©-renderizada, possui SEO amig√°vel, r√°pida para resposta, mas tamb√©m √© totalmente fornecida pelo SWR no cliente. Os dados podem ser din√¢micos e atualizados ao longo do tempo.

<Callout emoji="üí°">
O componente `Article` renderizar√° os dados pr√©-gerados primeiro, depois a p√°gina ser√° carregada, e ele ir√° buscar os dados mais recentes denovo para manter a atualiza√ß√£o.
</Callout>

### Chaves Complexas [#complex-keys]

`useSWR` pode ser usado com chaves que s√£o do tipo `array` e `function`. Usando dados pr√©-carregados com esses tipos de chaves requer serializar as chaves `fallback` com `unstable_serialize`.

```jsx
import useSWR, { unstable_serialize } from 'swr'

export async function getStaticProps () {
  const article = await getArticleFromAPI(1)
  return {
    props: {
      fallback: {
        // unstable_serialize() array style key
        [unstable_serialize(['api', 'article', 1])]: article,
      }
    }
  }
}

function Article() {
  // usando uma chave no estilo array.
  const { data } = useSWR(['api', 'article', 1], fetcher)
  return <h1>{data.title}</h1>
}

export default function Page({ fallback }) {
  return (
    <SWRConfig value={{ fallback }}>
      <Article />
    </SWRConfig>
  )
}
```
