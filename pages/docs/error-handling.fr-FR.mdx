import { Callout } from 'nextra-theme-docs'
import Link from 'next/link'

# Gestion des erreurs

Si une erreur est lev√©e √† l'int√©rieur de [`fetcher`](/docs/data-fetching), elle sera retourn√©e comme `error` par le hook.

```js
const fetcher = url => fetch(url).then(r => r.json())

// ...
const { data, error } = useSWR('/api/user', fetcher)
```

L'objet `error` sera d√©fini si la promesse de r√©cup√©ration est rejet√©e.

## Code d'√©tat et Objet d'erreur [#status-code-and-error-object]

Parfois, on veut qu'une API retourne un objet d'erreur avec le code d'√©tat.
Les deux sont utiles pour le client.

On peut personnaliser notre `fetcher` pour retourner plus d'informations. Si le code d'√©tat n'est pas `2xx`,
on consid√®re que c'est une erreur m√™me si elle peut √™tre analys√©e comme JSON :

```js
const fetcher = async url => {
  const res = await fetch(url)

  // Si le code d'√©tat n'est pas dans la plage 200-299,
  // on essaie quand m√™me de l'analyser et de le jeter.
  if (!res.ok) {
    const error = new Error('Une erreur est survenue lors de la r√©cup√©ration des donn√©es.')
    // Joignez des informations suppl√©mentaires √† l'objet d'erreur.
    error.info = await res.json()
    error.status = res.status
    throw error
  }

  return res.json()
}

// ...
const { data, error } = useSWR('/api/user', fetcher)
// error.info === {
//   message: "Vous n'√™tes pas autoris√© √† acc√©der √† cette ressource.",
//   documentation_url: "..."
// }
// error.status === 403
```

<Callout emoji="üí°">
  Notez que <code>data</code> et <code>error</code> peuvent exister en m√™me temps. Ainsi, l'interface utilisateur peut afficher les donn√©es existantes,
  tout en sachant que la demande √† venir a √©chou√©.
</Callout>

[Ici](/examples/error-handling), nous avons un exemple.

## Retenter sur Erreur [#error-retry]

SWR utilise l'[algorithme de backoff exponentiel](https://en.wikipedia.org/wiki/Exponential_backoff) pour retenter la requ√™te en cas d'erreur.
L'algorithme permet √† l'application de se remettre rapidement des erreurs, mais ne gaspille pas de ressources √† retenter trop souvent.

Vous pouvez personnaliser le comportement via l'option [`errorRetryInterval`](/docs/api#options) :

```js
useSWR('/api/user', fetcher, {
  onErrorRetry: (error, key, config, revalidate, { retryCount }) => {
    // Ne jamais retenter sur 404.
    if (error.status === 404) return

    // Ne pas retenter pour un cl√© sp√©cifique.
    if (key === '/api/user') return

    // Retenter 10 fois uniquement.
    if (retryCount >= 10) return

    // D√©lai de 5 secondes avant la prochaine tentative.
    setTimeout(() => revalidate({ retryCount }), 5000)
  }
})
```

Ce rappel vous donne la flexibilit√© de retenter en fonction de diverses conditions. Vous pouvez √©galement le d√©sactiver en d√©finissant `shouldRetryOnError: false`.

C'est aussi possible de le fournir via le contexte de [configuration globale](/docs/global-configuration).

## Rapport d'erreur globale [#global-error-report]

Vous pouvez toujours obtenir l'objet `error` √† l'int√©rieur du composant de mani√®re r√©active.
Mais si vous voulez g√©rer l'erreur globalement, pour notifier l'interface utilisateur d'afficher un [toast](https://vercel.com/design/toast) ou un [snackbar](https://material.io/components/snackbars), ou la signaler quelque part comme [Sentry](https://sentry.io),
il y a un √©v√©nement [`onError`](/docs/api#options) :

```jsx
<SWRConfig value={{
  onError: (error, key) => {
    if (error.status !== 403 && error.status !== 404) {
      // On peut envoyer l'erreur √† Sentry,
      // ou afficher une notification √† l'interface utilisateur.
    }
  }
}}>
  <MyApp />
</SWRConfig>
```
