import { Callout } from 'nextra-theme-docs'
import Video from 'components/video'

# Entendendo o SWR

## M√°quina de Estado [#state-machine]

`useSWR` retorna `data`, `error`, `isLoading` e `isValidating` dependendo do estado da fun√ß√£o `fetcher`. Esses diagramas descrevem como o SWR retorna valores em alguns cen√°rios.

### Obter e Revalidar [#fetch-and-revalidate]

Esse padr√£o √© para obter dados e revalidar depois.

![Um padr√£o para obter e revalidar](/img/understanding/fetch-and-revalidate.svg)

### Mudan√ßa de Chave [#key-change]

Esse padr√£o √© para obter dados, mudar a chave, e revalidar depois.

![Um padr√£o para mudan√ßa de chave.](/img/understanding/key-change.svg)i

### Mudan√ßa de Chave + Dados Antigos [#key-change--previous-data]

Esse padr√£o √© para obter dados, mudar a chave e revalidar depois usando a op√ß√£o `keepPreviousData`.

![Um padr√£o para mudan√ßa de chave + dados antigos](/img/understanding/key-change-previous-data.svg)

### Fallback [#fallback]

Esse padr√£o √© para obter dados e revalidar depois usando dados de fallback.

![Um padr√£o para fallback](/img/understanding/fallback.svg)

### Mudan√ßa de Chave + Fallback [#key-change--fallback]

Esse padr√£o √© para obter dados, mudar a chave e revalidar depois com dados de fallback.

![Um padr√£o para mudan√ßa de chave + fallback](/img/understanding/key-change-fallback.svg)

### Mudan√ßa de Chave + Dados Antigos + Fallback [#key-change--previous-data--fallback]

Esse padr√£o √© para obter dados, mudar a chave, revalidar depois usando a op√ß√£o `keepPreviousData` e com dados de fallback.

![Um padr√£o para mudan√ßa de chave + dados antigos + fallback](/img/understanding/key-change-previous-data-fallback.svg)

## Combinando com isLoading e isValidating para melhorar a UX [#combining-with-isloading-and-isvalidating-for-better-ux]

Comparado com o valor existente de `isValidating`, `isLoading` √© uma nova propriedade que pode te ajudar para os casos de carregamento mais gerais para UX.

- `isValidating` se torna `true` toda vez que h√° um requisi√ß√£o em andamento **independente se os dados foram carregados ou n√£o**
- `isLoading` se torna `true` quando h√° uma requisi√ß√£oo em andamento e **os dados ainda n√£o foram carregados**.

Simplesmente dizendo que voc√™ pode usar `isValidating` para indicar toda vez que h√° uma requisi√ß√£o em andamento e `isLoading` para indicar que o SWR est√° revalidando mas ainda n√£o h√° dados para exibir.

<Callout emoji="üìù">
  Dados de fallback e dados antigos n√£o s√£o considerados "dados carregados", ent√£o quando voc√™ usa dados de fallback ou habilita a op√ß√£o `keepPreviousData`, voc√™ talvez ter√° dados para exibir.
</Callout>

```jsx
function Stock() {
  const { data, isLoading, isValidating } = useSWR(STOCK_API, fetcher, {
    refreshInterval: 3000
  });

  // Se ainda estiver carregando os dados iniciais, n√£o h√° nada para exibir.
  // Iremos retornar um skeleton aqui.
  if (isLoading) return <div className="skeleton" />;

  // Se n√£o, exibiremos os dados e um spinner que indica a revalida√ß√£o
  //em segundo plano.
  return (
    <>
      <div>${data}</div>
      {isValidating ? <div className="spinner" /> : null}
    </>
  );
}
```

![Um exemplo de uso do isLoading](/img/understanding/isloading.gif)

Voc√™ pode achar o c√≥digo de exemplo [aqui](https://codesandbox.io/s/swr-isloading-jtopow)

## Retorne dados antigos para melhorar a UX [#return-previous-data-for-better-ux]

Quando estiver obtendo dados baseado em a√ß√µes cont√≠nuas do usu√°rio, como por exemplo, pesquisa em tempo real enquanto digita, manter os √∫ltimos dados obtidos pode melhorar bastante a UX. `keepPreviousData` √© uma op√ß√£o para habilitar esse comportamento. Aqui est√° uma UI de pesquisa simples:

```jsx
function Search() {
  const [search, setSearch] = React.useState('');

  const { data, isLoading } = useSWR(`/search?q=${search}`, fetcher, {
    keepPreviousData: true
  });

  return (
    <div>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="Pesquisar..."
      />

      <div className={isLoading ? "loading" : ""}>
        {data?.products.map(item => <Product key={item.id} name={item.name} />)
      </div>
    </div>
  );
}
```

Com o `keepPreviousData` habilitado, voc√™ ainda obter√° os dados antigos mesmo se voc√™ mudar a chave do SWR e a data com a chave nova come√ßar a carregar denovo.

<Video
  src="https://user-images.githubusercontent.com/3676859/163695903-a3eb1259-180e-41e0-821e-21c320201194.mp4"
  caption="Manter resultados de busca antigos quando keepPreviousData estiver habilitado"
  ratio={640/730}
/>

Voc√™ pode achar o c√≥digo completo para esse exemplo aqui: (https://codesandbox.io/s/swr-keeppreviousdata-fsjz3m).

## Cole√ß√£o de Depend√™ncia para performance [#dependency-collection-for-performance]

SWR apenas aciona a nova renderiza√ß√£o quando os estados usados no componente forem atualizados. Se voc√™ apenas usar `data` no componente, o SWR ir√° ignorar as atualiza√ß√µes das outras propriedades como `isValidating` e `isLoading`. Isso reduz bastante o n√∫mero de renderiza√ß√µes. Mais informa√ß√µes podem ser encontradas [aqui](/docs/advanced/performance#dependency-collection).

## onSuccess Callback [#on-success-callback]

Algumas vezes voc√™ pode querer rodar algum side-effect logo ap√≥s seus dados serem requisitados com sucesso. Voc√™ pode usar a op√ß√£p de callback `onSuccess` para fazer isso.

```jsx
const { data } = useSWR('/api/user', fetcher, {
  onSuccess: (data, key, config) => {
    // Registra uma chamada de API com sucesso
    analytics.track('API Sucesso', {
      endpoint: key,
      timestamp: new Date(),
      data: data
    });
  }
});
```

SWR vai chamar o callback `onSuccess` com o dado retornado, a chave, e o objeto de configura√ß√£o. Isso √© bastante √∫til para analytics, logging, ou qualquer outro side effect que voc√™ queira rodar depois de uma requisi√ß√£o bem-sucedida.

### `onSuccess` com deduplica√ß√£o

Uma das features do SWR √© a deduplica√ß√£o, que significa que se a mesma chave estiver sendo usada em multiplos lugares ao mesmo tempo, o SWR vai fazer apenas uma requisis√ß√£o e compartilhar o dado retornado entre os componentes.

Somente a primeira fun√ß√£o de callback `onSuccess` definida vai ser chamada para a primeira requisi√ß√£o feita com sucesso, mesmo se `onSuccess` estiver definido em multiplos lugares.

Exemplo:

```jsx
const FirstComponent = () => {
  const { data } = useSWR('/api/user', fetcher, {
    onSuccess: (data) => {
      // esse callback onSuccess ser√° chamado
      console.log('Primeiro component successo:', data);
    }
  });
  return <div>{data?.name}</div>;
};

const SecondComponent = () => {
  const { data } = useSWR('/api/user', fetcher, {
    onSuccess: (data) => {
      // esse callback onSuccess N√ÉO ser√° chamado
      console.log('Segundo componente successo:', data);
    }
  });
  return <div>{data?.email}</div>;
};

const App = () => (
  <>
    <FirstComponent />
    <SecondComponent />
  </>
);
```

O exemplo acima vai logar apenas a mensagem de sucesso do primeiro componente quando os dados forem retornados com sucesso, mesmo que ambos os componentes tenham seus pr√≥prios callbacks `onSuccess`. Isso acontece porque o SWR deduplica as requisi√ß√µes para a mesma chave.

Por essa raz√£o, voc√™ deve evitar user `onSuccess` para atualizar estado local, j√° que isso pode levar a comportamentes inexperados quando multiplos componente estiverem usando a mesma chave.

Tamb√©m, o callback `onSuccess` n√£o √© chamado quando o dados for carregado do cache, somente quando for retordado da rede. Se voc√™ precisa rodar qualquer side effect para dados cacheados, considere usar o hook `useEffect` em combina√ß√£o com os dados do SWR.

```jsx
const { data } = useSWR('/api/user', fetcher);

useEffect(() => {
  if (data) {
    // Executar side effects para dados cacheados
    console.log('Cached data:', data);
  }
}, [data]);
```
