import { Callout } from 'nextra-theme-docs'
import Video from 'components/video'

# Entendendo o SWR

## M√°quina de Estado [#state-machine]

`useSWR` retorna `data`, `error`, `isLoading` e `isValidating` dependendo do estado da fun√ß√£o `fetcher`. Esses diagramas descrevem como o SWR retorna valores em alguns cen√°rios.

### Obter e Revalidar [#fetch-and-revalidate]

Esse padr√£o √© para obter dados e revalidar depois.

![Um padr√£o para obter e revalidar](/img/understanding/fetch-and-revalidate.svg)

### Mudan√ßa de Chave [#key-change]

Esse padr√£o √© para obter dados, mudar a chave, e revalidar depois.

![Um padr√£o para mudan√ßa de chave.](/img/understanding/key-change.svg)i

### Mudan√ßa de Chave + Dados Antigos [#key-change--previous-data]

Esse padr√£o √© para obter dados, mudar a chave e revalidar depois usando a op√ß√£o `keepPreviousData`.

![Um padr√£o para mudan√ßa de chave + dados antigos](/img/understanding/key-change-previous-data.svg)

### Fallback [#fallback]

Esse padr√£o √© para obter dados e revalidar depois usando dados de fallback.

![Um padr√£o para fallback](/img/understanding/fallback.svg)

### Mudan√ßa de Chave + Fallback [#key-change--fallback]

Esse padr√£o √© para obter dados, mudar a chave e revalidar depois com dados de fallback.

![Um padr√£o para mudan√ßa de chave + fallback](/img/understanding/key-change-fallback.svg)

### Mudan√ßa de Chave + Dados Antigos + Fallback [#key-change--previous-data--fallback]

Esse padr√£o √© para obter dados, mudar a chave, revalidar depois usando a op√ß√£o `keepPreviousData` e com dados de fallback.

![Um padr√£o para mudan√ßa de chave + dados antigos + fallback](/img/understanding/key-change-previous-data-fallback.svg)

## Combinando com isLoading e isValidating para melhorar a UX [#combining-with-isloading-and-isvalidating-for-better-ux]

Comparado com o valor existente de `isValidating`, `isLoading` √© uma nova propriedade que pode te ajudar para os casos de carregamento mais gerais para UX.

- `isValidating` se torna `true` toda vez que h√° um requisi√ß√£o em andamento **independente se os dados foram carregados ou n√£o**
- `isLoading` se torna `true` quando h√° uma requisi√ß√£oo em andamento e **os dados ainda n√£o foram carregados**.

Simplesmente dizendo que voc√™ pode usar `isValidating` para indicar toda vez que h√° uma requisi√ß√£o em andamento e `isLoading` para indicar que o SWR est√° revalidando mas ainda n√£o h√° dados para exibir.

<Callout emoji="üìù">
  Dados de fallback e dados antigos n√£o s√£o considerados "dados carregados", ent√£o quando voc√™ usa dados de fallback ou habilita a op√ß√£o `keepPreviousData`, voc√™ talvez ter√° dados para exibir.
</Callout>

```jsx
function Stock() {
  const { data, isLoading, isValidating } = useSWR(STOCK_API, fetcher, {
    refreshInterval: 3000
  });

  // Se ainda estiver carregando os dados iniciais, n√£o h√° nada para exibir.
  // Iremos retornar um skeleton aqui.
  if (isLoading) return <div className="skeleton" />;

  // Se n√£o, exibiremos os dados e um spinner que indica a revalida√ß√£o
  //em segundo plano.
  return (
    <>
      <div>${data}</div>
      {isValidating ? <div className="spinner" /> : null}
    </>
  );
}
```

![Um exemplo de uso do isLoading](/img/understanding/isloading.gif)

Voc√™ pode achar o c√≥digo de exemplo [aqui](https://codesandbox.io/s/swr-isloading-jtopow)

## Retorne dados antigos para melhorar a UX [#return-previous-data-for-better-ux]

Quando estiver obtendo dados baseado em a√ß√µes cont√≠nuas do usu√°rio, como por exemplo, pesquisa em tempo real enquanto digita, manter os √∫ltimos dados obtidos pode melhorar bastante a UX. `keepPreviousData` √© uma op√ß√£o para habilitar esse comportamento. Aqui est√° uma UI de pesquisa simples:

```jsx
function Search() {
  const [search, setSearch] = React.useState('');

  const { data, isLoading } = useSWR(`/search?q=${search}`, fetcher, {
    keepPreviousData: true
  });

  return (
    <div>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="Pesquisar..."
      />

      <div className={isLoading ? "loading" : ""}>
        {data?.products.map(item => <Product key={item.id} name={item.name} />)
      </div>
    </div>
  );
}
```

Com o `keepPreviousData` habilitado, voc√™ ainda obter√° os dados antigos mesmo se voc√™ mudar a chave do SWR e a data com a chave nova come√ßar a carregar denovo.

<Video
  src="https://user-images.githubusercontent.com/3676859/163695903-a3eb1259-180e-41e0-821e-21c320201194.mp4"
  caption="Manter resultados de busca antigos quando keepPreviousData estiver habilitado"
  ratio={640/730}
/>

Voc√™ pode achar o c√≥digo completo para esse exemplo aqui: (https://codesandbox.io/s/swr-keeppreviousdata-fsjz3m).

## Cole√ß√£o de Depend√™ncia para performance [#dependency-collection-for-performance]

SWR apenas aciona a nova renderiza√ß√£o quando os estados usados no componente forem atualizados. Se voc√™ apenas usar `data` no componente, o SWR ir√° ignorar as atualiza√ß√µes das outras propriedades como `isValidating` e `isLoading`. Isso reduz bastante o n√∫mero de renderiza√ß√µes. Mais informa√ß√µes podem ser encontradas [aqui](/docs/advanced/performance#dependency-collection).
