import { Callout } from 'nextra-theme-docs'
import Video from 'components/video'

# Compr√©hension SWR

## Etat de la Machine [#state-machine]

`useSWR` renvoie `data`, `error`, `isLoading`, et `isValidating`, en fonction de l'√©tat de la fonction `fetcher`. Ces diagrammes d√©crivent comment SWR renvoie ces valeurs dans plusieurs sc√©narios.

### R√©cup√©ration et Revalidation [#fetch-and-revalidate]

Ce diagramme montre la r√©cup√©reration des donn√©es et la revalidation plus tard.

![R√©cup√©ration et revalidation](/img/understanding/fetch-and-revalidate.svg)

### Changement de Cl√© [#key-change]

Ce diagramme montre la r√©cup√©ration des donn√©es et le changement de cl√© plus tard.

![Changement de Cl√©](/img/understanding/key-change.svg)

### Changement de Cl√© + Donn√©es Pr√©c√©dentes [#key-change--previous-data]

Ce diagramme montre la r√©cup√©ration des donn√©es et le changement de cl√© plus tard avec l'option `keepPreviousData`.

![Changement de Cl√© + Donn√©es Pr√©c√©dentes](/img/understanding/key-change-previous-data.svg)

### Repli [#fallback]

Ce diagramme montre la r√©cup√©ration des donn√©es et la revalidation plus tard avec les donn√©es de repli.

![Repli](/img/understanding/fallback.svg)

### Changement de Cl√© + Repli [#key-change--fallback]

Ce diagramme montre la r√©cup√©ration des donn√©es et le changement de cl√© plus tard avec les donn√©es de repli.

![Changement de Cl√© + Repli](/img/understanding/key-change-fallback.svg)

### Changement de Cl√© + Donn√©es Pr√©c√©dentes + Repli [#key-change--previous-data--fallback]

Ce diagramme montre la r√©cup√©ration des donn√©es et le changement de cl√© plus tard avec les donn√©es de repli et l'option `keepPreviousData`.

![Changement de Cl√© + Donn√©es Pr√©c√©dentes + Repli](/img/understanding/key-change-previous-data-fallback.svg)

## Combiner isLoading et isValidating pour une meilleure UX [#combining-with-isloading-and-isvalidating-for-better-ux]

Compar√© √† la valeur existante `isValidating`, `isLoading` est une nouvelle propri√©t√© qui peut vous aider pour les cas de chargement plus g√©n√©raux pour l'UX.

- `isValidating` devient `true` √† chaque fois qu'il y a une requ√™te en cours **que les donn√©es soient charg√©es ou non**
- `isLoading` devient `true` lorsqu'il y a une requ√™te en cours et que **les donn√©es ne sont pas encore charg√©es**.

En d'autres termes, `isLoading` est une propri√©t√© plus sp√©cifique pour indiquer que les donn√©es ne sont pas encore charg√©es. `isValidating` est une propri√©t√© plus g√©n√©rale pour indiquer qu'il y a une revalidation en cours, que les donn√©es soient charg√©es ou non.

<Callout emoji="üìù">
  Les donn√©es de repli et pr√©c√©dentes ne sont pas consid√©r√©es comme des "donn√©es charg√©es", donc lorsque vous utilisez des donn√©es de repli ou que vous activez l'option keepPreviousData, vous pouvez avoir des donn√©es √† afficher.
</Callout>

```jsx
function Stock() {
  const { data, isLoading, isValidating } = useSWR(STOCK_API, fetcher, {
    refreshInterval: 3000
  });

  // Si les donn√©es initiales sont toujours en cours de chargement, il n'y a rien √† afficher.
  // Nous retournons un squelette ici.
  if (isLoading) return <div className="skeleton" />;

  // Sinon, nous affichons les donn√©es et un spinner qui indique une revalidation en arri√®re-plan.
  return (
    <>
      <div>${data}</div>
      {isValidating ? <div className="spinner" /> : null}
    </>
  );
}
```

![Un exemple d'utilisation de isLoading](/img/understanding/isloading.gif)

Vous pouvez trouver l'exemple [ici](https://codesandbox.io/s/swr-isloading-jtopow)

## Renvoi de donn√©es pr√©c√©dentes pour une meilleure UX [#return-previous-data-for-better-ux]

Lors de la r√©cup√©ration de donn√©es bas√©e sur des actions utilisateurs, par exemple une recherche en temps r√©el, garder les donn√©es pr√©c√©dentes peut al√©liorer l'UX. `keepPreviousData` est une option pour activer ce comportement. Voici une simple interface de recherche :

```jsx
function Search() {
  const [search, setSearch] = React.useState('');

  const { data, isLoading } = useSWR(`/search?q=${search}`, fetcher, {
    keepPreviousData: true
  });

  return (
    <div>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="Rechercher..."
      />

      <div className={isLoading ? "chargement" : ""}>
        {data?.products.map(item => <Product key={item.id} name={item.name} />)}
      </div>
    </div>
  );
}
```

Avec `keepPreviousData` activ√©, vous obtiendrez toujours les donn√©es pr√©c√©dentes m√™me si vous changez la cl√© SWR et que les donn√©es pour la nouvelle cl√© commencent √† se charger √† nouveau.

<Video
  src="https://user-images.githubusercontent.com/3676859/163695903-a3eb1259-180e-41e0-821e-21c320201194.mp4"
  caption="Sauvegarde des pr√©c√©dents r√©sultats de recherche quant keepPreviousData est actif"
  ratio={640/730}
/>

Vous pouvez trouver l'exemple [ici](https://codesandbox.io/s/swr-keeppreviousdata-fsjz3m).

## Collection de d√©pendances pour les performances [#dependency-collection-for-performance]

SWR ne d√©clenche le re-rendering que lorsque les √©tats utilis√©s dans le composant ont √©t√© mis √† jour. Si vous n'utilisez que `data` dans le composant, SWR ignore les mises √† jour des autres propri√©t√©s comme `isValidating` et `isLoading`. Cela r√©duit consid√©rablement le nombre de rendus. Vous pouvez trouver plus d'informations [ici](/docs/advanced/performance#dependency-collection).

## onSuccess Callback [#on-success-callback]

Sometimes you may want to run some side effects right after the data is fetched successfully. You can use the `onSuccess` callback option to do that.

```jsx
const { data } = useSWR('/api/user', fetcher, {
  onSuccess: (data, key, config) => {
    // Track successful API calls
    analytics.track('API Success', {
      endpoint: key,
      timestamp: new Date(),
      data: data
    });
  }
});
```

SWR will call the `onSuccess` callback with the fetched data, the key, and the config object. This is useful for analytics, logging, or any other side effects you want to perform after a successful fetch.

### `onSuccess` with deduplication

One of the features of SWR is deduplication, which means that if the same key is being used in multiple places at the same time, SWR will only fetch the data once and share it among those components.

Only the first `onSuccess` callback defined will be called for the first successful fetch, even if `onSuccess` is defined in multiple places.

Example:

```jsx
const FirstComponent = () => {
  const { data } = useSWR('/api/user', fetcher, {
    onSuccess: (data) => {
      // this on success will be called
      console.log('First component success:', data);
    }
  });
  return <div>{data?.name}</div>;
};

const SecondComponent = () => {
  const { data } = useSWR('/api/user', fetcher, {
    onSuccess: (data) => {
      // this on success will NOT be called
      console.log('Second component success:', data);
    }
  });
  return <div>{data?.email}</div>;
};

const App = () => (
  <>
    <FirstComponent />
    <SecondComponent />
  </>
);
```

The example above will only log the success message from the first component when the data is fetched successfully, even though both components have their own `onSuccess` callbacks. This is because SWR deduplicates requests for the same key.

For this reason, you should avoid using `onSuccess` to set local state in the `onSuccess` callback, as it may lead to unexpected behavior when multiple components are using the same key.

Also, the `onSuccess` callback is not called when the data is loaded from the cache, only when it is fetched from the network. If you need to run side effects for cached data, consider using the `useEffect` hook in combination with SWR's data.

```jsx
const { data } = useSWR('/api/user', fetcher);

useEffect(() => {
  if (data) {
    // Run side effects for cached data
    console.log('Cached data:', data);
  }
}, [data]);
```
