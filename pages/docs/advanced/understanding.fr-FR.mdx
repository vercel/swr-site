import { Callout } from 'nextra-theme-docs'
import Video from 'components/video'

# Compr√©hension SWR

## Etat de la Machine [#state-machine]

`useSWR` renvoie `data`, `error`, `isLoading`, et `isValidating`, en fonction de l'√©tat de la fonction `fetcher`. Ces diagrammes d√©crivent comment SWR renvoie ces valeurs dans plusieurs sc√©narios.

### R√©cup√©ration et Revalidation [#fetch-and-revalidate]

Ce diagramme montre la r√©cup√©reration des donn√©es et la revalidation plus tard.

![R√©cup√©ration et revalidation](/img/understanding/fetch-and-revalidate.svg)

### Changement de Cl√© [#key-change]

Ce diagramme montre la r√©cup√©ration des donn√©es et le changement de cl√© plus tard.

![Changement de Cl√©](/img/understanding/key-change.svg)

### Changement de Cl√© + Donn√©es Pr√©c√©dentes [#key-change--previous-data]

Ce diagramme montre la r√©cup√©ration des donn√©es et le changement de cl√© plus tard avec l'option `keepPreviousData`.

![Changement de Cl√© + Donn√©es Pr√©c√©dentes](/img/understanding/key-change-previous-data.svg)

### Repli [#fallback]

Ce diagramme montre la r√©cup√©ration des donn√©es et la revalidation plus tard avec les donn√©es de repli.

![Repli](/img/understanding/fallback.svg)

### Changement de Cl√© + Repli [#key-change--fallback]

Ce diagramme montre la r√©cup√©ration des donn√©es et le changement de cl√© plus tard avec les donn√©es de repli.

![Changement de Cl√© + Repli](/img/understanding/key-change-fallback.svg)

### Changement de Cl√© + Donn√©es Pr√©c√©dentes + Repli [#key-change--previous-data--fallback]

Ce diagramme montre la r√©cup√©ration des donn√©es et le changement de cl√© plus tard avec les donn√©es de repli et l'option `keepPreviousData`.

![Changement de Cl√© + Donn√©es Pr√©c√©dentes + Repli](/img/understanding/key-change-previous-data-fallback.svg)

## Combiner isLoading et isValidating pour une meilleure UX [#combining-with-isloading-and-isvalidating-for-better-ux]

Compar√© √† la valeur existante `isValidating`, `isLoading` est une nouvelle propri√©t√© qui peut vous aider pour les cas de chargement plus g√©n√©raux pour l'UX.

- `isValidating` devient `true` √† chaque fois qu'il y a une requ√™te en cours **que les donn√©es soient charg√©es ou non**
- `isLoading` devient `true` lorsqu'il y a une requ√™te en cours et que **les donn√©es ne sont pas encore charg√©es**.

En d'autres termes, `isLoading` est une propri√©t√© plus sp√©cifique pour indiquer que les donn√©es ne sont pas encore charg√©es. `isValidating` est une propri√©t√© plus g√©n√©rale pour indiquer qu'il y a une revalidation en cours, que les donn√©es soient charg√©es ou non.

<Callout emoji="üìù">
  Les donn√©es de repli et pr√©c√©dentes ne sont pas consid√©r√©es comme des "donn√©es charg√©es", donc lorsque vous utilisez des donn√©es de repli ou que vous activez l'option keepPreviousData, vous pouvez avoir des donn√©es √† afficher.
</Callout>

```jsx
function Stock() {
  const { data, isLoading, isValidating } = useSWR(STOCK_API, fetcher, {
    refreshInterval: 3000
  });

  // Si les donn√©es initiales sont toujours en cours de chargement, il n'y a rien √† afficher.
  // Nous retournons un squelette ici.
  if (isLoading) return <div className="skeleton" />;

  // Sinon, nous affichons les donn√©es et un spinner qui indique une revalidation en arri√®re-plan.
  return (
    <>
      <div>${data}</div>
      {isValidating ? <div className="spinner" /> : null}
    </>
  );
}
```

![Un exemple d'utilisation de isLoading](/img/understanding/isloading.gif)

Vous pouvez trouver l'exemple [ici](https://codesandbox.io/s/swr-isloading-jtopow)

## Renvoi de donn√©es pr√©c√©dentes pour une meilleure UX [#return-previous-data-for-better-ux]

Lors de la r√©cup√©ration de donn√©es bas√©e sur des actions utilisateurs, par exemple une recherche en temps r√©el, garder les donn√©es pr√©c√©dentes peut al√©liorer l'UX. `keepPreviousData` est une option pour activer ce comportement. Voici une simple interface de recherche :

```jsx
function Search() {
  const [search, setSearch] = React.useState('');

  const { data, isLoading } = useSWR(`/search?q=${search}`, fetcher, {
    keepPreviousData: true
  });

  return (
    <div>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="Rechercher..."
      />

      <div className={isLoading ? "chargement" : ""}>
        {data?.products.map(item => <Product key={item.id} name={item.name} />)}
      </div>
    </div>
  );
}
```

Avec `keepPreviousData` activ√©, vous obtiendrez toujours les donn√©es pr√©c√©dentes m√™me si vous changez la cl√© SWR et que les donn√©es pour la nouvelle cl√© commencent √† se charger √† nouveau.

<Video
  src="https://user-images.githubusercontent.com/3676859/163695903-a3eb1259-180e-41e0-821e-21c320201194.mp4"
  caption="Sauvegarde des pr√©c√©dents r√©sultats de recherche quant keepPreviousData est actif"
  ratio={640/730}
/>

Vous pouvez trouver l'exemple [ici](https://codesandbox.io/s/swr-keeppreviousdata-fsjz3m).

## Collection de d√©pendances pour les performances [#dependency-collection-for-performance]

SWR ne d√©clenche le re-rendering que lorsque les √©tats utilis√©s dans le composant ont √©t√© mis √† jour. Si vous n'utilisez que `data` dans le composant, SWR ignore les mises √† jour des autres propri√©t√©s comme `isValidating` et `isLoading`. Cela r√©duit consid√©rablement le nombre de rendus. Vous pouvez trouver plus d'informations [ici](/docs/advanced/performance#dependency-collection).
