import Callout from 'nextra-theme-docs/callout'

# Pagina√ß√£o

<Callout emoji="‚úÖ">
    Por favor atualize para a vers√£o mais recente (‚â• 0.3.0) para usar esta API. A API <code>useSWRPages</code> anterior est√° descontinuada.
</Callout>

SWR prov√™ uma API dedicada `useSWRInfinite` para lidar com padr√µes de interface comuns como **pagina√ß√£o** e **carregamento infinito**.

## Quando Usar `useSWR`

### Pagina√ß√£o

Antes de tudo, n√≥s podemos **N√ÉO** precisar de `useSWRInfinite` mas podemos usar apenas `useSWR` se estamos construindo algo como isso:

import { Pagination } from 'components/diagrams/pagination'

<div className="mt-8">
  <Pagination/>
</div>

...que √© uma interface t√≠pica de pagina√ß√£o. Veja como pode ser facilmente implementado com `useSWR`:

```jsx {5}
function App () {
  const [pageIndex, setPageIndex] = useState(0);

  // A URL da API inclui o √≠ndice da p√°gina, que √© um estado do React.
  const { data } = useSWR(`/api/data?page=${pageIndex}`, fetcher);

  // ... lidando com estados de loading e erro

  return <div>
    {data.map(item => <div key={item.id}>{item.name}</div>)}
    <button onClick={() => setPageIndex(pageIndex - 1)}>Previous</button>
    <button onClick={() => setPageIndex(pageIndex + 1)}>Next</button>
  </div>
}
```

Al√©m disso, podemos criar uma abstra√ß√£o para este "componente de p√°gina":

```jsx {13}
function Page ({ index }) {
  const { data } = useSWR(`/api/data?page=${index}`, fetcher);

  // ... lidando com estados de loading e erro

  return data.map(item => <div key={item.id}>{item.name}</div>)
}

function App () {
  const [pageIndex, setPageIndex] = useState(0);

  return <div>
    <Page index={pageIndex}/>
    <button onClick={() => setPageIndex(pageIndex - 1)}>Previous</button>
    <button onClick={() => setPageIndex(pageIndex + 1)}>Next</button>
  </div>
}
```

Por causa do cache do SWR, temos o benef√≠cio de pr√©-carregar a pr√≥xima p√°gina. Renderizamos a pr√≥xima p√°gina dentro
um div oculto, SWR acionar√° a busca de dados da pr√≥xima p√°gina. Quando o usu√°rio navega para a pr√≥xima p√°gina, os dados j√° est√£o l√°:

```jsx {6}
function App () {
  const [pageIndex, setPageIndex] = useState(0);

  return <div>
    <Page index={pageIndex}/>
    <div style={{ display: 'none' }}><Page index={pageIndex + 1}/></div>
    <button onClick={() => setPageIndex(pageIndex - 1)}>Previous</button>
    <button onClick={() => setPageIndex(pageIndex + 1)}>Next</button>
  </div>
}
```

Com apenas 1 linha de c√≥digo, obtemos uma UX muito melhor. O hook `useSWR` √© t√£o poderoso que a maioria dos cen√°rios s√£o cobertos por ele.

### Carregamento Infinito

√Äs vezes, queremos criar uma UI de **carregamento infinito**, com um bot√£o "Carregar mais" que anexa dados
para a lista (ou feito automaticamente quando voc√™ rola):

import { Infinite } from 'components/diagrams/infinite'

<div className="mt-8">
  <Infinite/>
</div>

Para implementar isso, precisamos fazer **n√∫mero din√¢mico de solicita√ß√µes** nesta p√°gina. Os React Hooks tem [algumas regras](https://pt-br.reactjs.org/docs/hooks-rules.html),
ent√£o n√≥s **N√ÉO PODEMOS** fazer algo assim:

```jsx {5,6,7,8,9}
function App () {
  const [cnt, setCnt] = useState(1)

  const list = []
  for (let i = 0; i < cnt; i++) {
    // üö® Isso √© errado! Comumente, voc√™ n√£o pode usar hooks dentro de um loop.
    const { data } = useSWR(`/api/data?page=${i}`)
    list.push(data)
  }

  return <div>
    {list.map((data, i) =>
      <div key={i}>{
        data.map(item => <div key={item.id}>{item.name}</div>)
      }</div>)}
    <button onClick={() => setCnt(cnt + 1)}>Load More</button>
  </div>
}
```

Ao inv√©s disso, podemos usar a abstra√ß√£o `<Page />` que criamos para conseguir isso:

```jsx {5,6,7}
function App () {
  const [cnt, setCnt] = useState(1)

  const pages = []
  for (let i = 0; i < cnt; i++) {
    pages.push(<Page index={i} key={i} />)
  }

  return <div>
    {pages}
    <button onClick={() => setCnt(cnt + 1)}>Load More</button>
  </div>
}
```

### Casos Avan√ßados

Entretanto, em alguns casos avan√ßados, a solu√ß√£o acima n√£o funciona.

Por exemplo, n√≥s ainda estamos implementando o mesmo "Carregar mais", mas tamb√©m precisamos mostrar um n√∫mero
sobre quantos itens existem no total. N√≥s n√£o podemos usar o `<Page />` novamente porque
a top level UI (`<App />`) precisa dos dados dentro de cada p√°gina:

```jsx {10}
function App () {
  const [cnt, setCnt] = useState(1)

  const pages = []
  for (let i = 0; i < cnt; i++) {
    pages.push(<Page index={i} key={i} />)
  }

  return <div>
    <p>??? items</p>
    {pages}
    <button onClick={() => setCnt(cnt + 1)}>Load More</button>
  </div>
}
```

Tamb√©m, se a API de pagina√ß√£o for **baseada em cursor**, essa solu√ß√£o n√£o funciona tamb√©m. Porque cada p√°gina
precisa dos dados da p√°gina interior, elas n√£o s√£o isoladas.

√â assim que esse novo hook `useSWRInfinite` pode ajudar.

## useSWRInfinite

`useSWRInfinite` nos d√° a habilidade de disparar uma quantidade de solicita√ß√µes com um Hook. Isso √© como se fosse:

```jsx
import useSWRInfinite from 'swr/infinite'

// ...
const { data, error, isValidating, mutate, size, setSize } = useSWRInfinite(
  getKey, fetcher?, options?
)
```

Similar ao `useSWR`, esse novo Hook aceita uma fun√ß√£o que retorna a chave de pedido, uma fun√ß√£o de busca, e op√ß√µes.
Ele retorna todos os valores que `useSWR` retorna, incluindo 2 valores extras: o tamanho da p√°gina e um setter do tamanho da p√°gina, como um state do React.

In infinite loading, one _page_ is one request, and our goal is to fetch multiple pages and render them.

<Callout emoji="‚ö†Ô∏è">
  Se voc√™ est√° usando vers√µes SWR 0.x, `useSWRInfinite` precisa ser importado de `swr`:<br/>
  `import { useSWRInfinite } from 'swr'`
</Callout>

### API

#### Par√¢metros

- `getKey`: uma fun√ß√£o que aceita o √≠ndice e os dados da p√°gina anterior, retorna a chave de uma p√°gina
- `fetcher`: mesma fun√ß√£o que a [fun√ß√£o fetcher](/docs/data-fetching) do `useSWR`.
- `options`: aceita todas as op√ß√µes que `useSWR` suporta, com 4 op√ß√µes adicionais:
  - `initialSize=1`: n√∫mero de p√°ginas devem ser carregadas inicialmente
    - `revalidateAll=false`: sempre tentar revalidar todas as p√°ginas
    - `revalidateFirstPage=true`: sempre tentar revalidar a primeira p√°gina
    - `persistSize=false`: n√£o reseta o tamanho da p√°gina para 1 (ou `initialSize` se setado) quando a chave da primeira p√°gina muda

<Callout>
  Note que a op√ß√£o `initialSize` n√£o √© permitida a mudar no ciclo de vida.
</Callout>

#### Valores de Retorno

- `data`: an array of fetch response values of each page
- `error`: same as `useSWR`'s `error`
- `isValidating`: same as `useSWR`'s `isValidating`
- `mutate`: same as `useSWR`'s bound mutate function but manipulates the data array
- `size`: the number of pages that _will_ be fetched and returned
- `setSize`: set the number of pages that need to be fetched

- `data`: um array de respostas de fetch para cada p√°gina
- `error`: mesma que o objeto `error` do `useSWR`.
- `isValidating`: mesmo que o `isValidating` do `useSWR`.
- `mutate`: igual √† fun√ß√£o de muta√ß√£o vinculada do `useSWR`, mas manipula o array de dados
- `size`: o n√∫mero de p√°ginas que _v√£o_ ser carregadas e retornadas
- `setSize`: define o n√∫mero de p√°ginas que precisam ser carregadas

### Exemplo 1: API de Pagina√ß√£o Baseada em √çndice

Para APIs baseadas em √≠ndice:

```plaintext
GET /users?page=0&limit=10
[
  { name: 'Alice', ... },
  { name: 'Bob', ... },
  { name: 'Cathy', ... },
  ...
]
```

```jsx {4,5,6,7,10}
// A fun√ß√£o para obter a chave SWR de cada p√°gina,
// o valor retornado ser√° aceito pela fun√ß√£o `fetcher`.
// Se o valor `null` √© retornado, a solicita√ß√£o da p√°gina n√£o iniciar√°.
const getKey = (pageIndex, previousPageData) => {
  if (previousPageData && !previousPageData.length) return null // atingiu o fim
  return `/users?page=${pageIndex}&limit=10`                    // chave SWR
}

function App () {
  const { data, size, setSize } = useSWRInfinite(getKey, fetcher)
  if (!data) return 'loading'

  // Agora podemos calcular o n√∫mero total de usu√°rios
  let totalUsers = 0
  for (let i = 0; i < data.length; i++) {
    totalUsers += data[i].length
  }

  return <div>
    <p>{totalUsers} users listed</p>
    {data.map((users, index) => {
      // `data` √© um array de respostas da API de cada p√°gina.
      return users.map(user => <div key={user.id}>{user.name}</div>)
    })}
    <button onClick={() => setSize(size + 1)}>Load More</button>
  </div>
}
```

The `getKey` function is the major difference between `useSWRInfinite` and `useSWR`.
It accepts the index of the current page, as well as the data from the previous page.
So both index based and cursor based pagination API can be supported nicely.

A fun√ß√£o `getKey` √© a diferen√ßa maior entre `useSWRInfinite` e `useSWR`.
Ela aceita o √≠ndice da p√°gina atual, bem como os dados da p√°gina anterior.
Ent√£o ambas (pagina√ß√£o baseada em √≠ndice e p√°gina√ß√£o baseada em cursor) podem ser suportadas.

Tamb√©m, `data` n√£o √© mais apenas uma resposta da API. √â um array de respostas da API:

```js
// `data` se parecer√° com isso
[
  [
    { name: 'Alice', ... },
    { name: 'Bob', ... },
    { name: 'Cathy', ... },
    ...
  ],
  [
    { name: 'John', ... },
    { name: 'Paul', ... },
    { name: 'George', ... },
    ...
  ],
  ...
]
```

### Exemplo 2: API de Pagina√ß√£o Baseada em Cursor ou Offset

Vamos dizer que a API agora requer um cursor e retorna o pr√≥ximo cursor junto com os dados:

```plaintext
GET /users?cursor=123&limit=10
{
  data: [
    { name: 'Alice' },
    { name: 'Bob' },
    { name: 'Cathy' },
    ...
  ],
  nextCursor: 456
}
```

N√≥s podemos mudar nossa fun√ß√£o `getKey` para:

```jsx
const getKey = (pageIndex, previousPageData) => {
  // alcan√ßou o fim
  if (previousPageData && !previousPageData.data) return null

  // primeira p√°gina, n√≥s n√£o temos `previousPageData`
  if (pageIndex === 0) return `/users?limit=10`

  // adiciona o cursor para o endpoint da API
  return `/users?cursor=${previousPageData.nextCursor}&limit=10`
}
```

### Funcionalidades Avan√ßadas

[Aqui tem um exemplo](/examples/infinite-loading) mostrando como voc√™ pode implementar as seguintes funcionalidades com `useSWRInfinite`:

- estados de carregamento
- mostrar uma interface especial se estiver vazio
- desativar o bot√£o "Carregar mais" se alcan√ßou o fim
- fonte de dados alter√°vel
- atualizar toda a lista
