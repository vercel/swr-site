import { Callout } from 'nextra-theme-docs'

# Utilisation avec Next.js

## App Router [#app-dir]

### Server Components [#rsc]

<Callout type="default" emoji="‚úÖ">
   In Next.js App Router, all components are React Server Components (RSC) by default. **You could only import the key serialization APIs from SWR in RSC.**
</Callout>

```tsx filename="app/page.tsx" copy
import { unstable_serialize } from 'swr' // ‚úÖ works
import { unstable_serialize as infinite_unstable_serialize } from 'swr/infinite' // ‚úÖ works
```

<Callout type="error">
   You could not import any other APIs from SWR since they are not available in RSC.
</Callout>

```tsx filename="app/page.tsx" highlight={1}
import useSWR from 'swr' // ‚ùå it will throw an error
```

### Client Components

You need to mark your components with `'use client'` directive so that SWR could work properly.

```tsx filename="app/page.tsx" highlight={1} copy
'use client'
import useSWR from 'swr'
export default Page() {
  const { data } = useSWR('/api/user', fetcher)
  return <h1>{data.name}</h1>
}
```

If you need to use `SWRConfig` to do some global setup in your `layout` or `page` component, but you also don't want to make them client components. You could create a separate provider component.

```tsx filename="app/swr-provider.tsx" copy
'use client';
import { SWRConfig } from 'swr'
export const SWRProvider = ({ children }) => {
  return <SWRConfig>{children}</SWRConfig>
};
```

```tsx filename="app/page.tsx" copy
// This is still a server component
import { SWRProvider } from './swr-provider'
export default Page() {
  return (
    <SWRProvider>
      <h1>hello SWR</h1>
    </SWRProvider>
  )
}
```

## R√©cup√©ration de donn√©es c√¥t√© client [#client-side-data-fetching]

Si votre page contient des donn√©es qui sont mises √† jour fr√©quemment, et que vous n'avez pas besoin de pr√©-rendre les donn√©es, SWR correspond et ne n√©cessite aucune configuration sp√©ciale : importez simplement `useSWR` et utilisez le hook dans n'importe quelle composant qui utilise les donn√©es.

Voila comment √ßa marche :

- Premi√®rement, affichez imm√©diatement la page sans donn√©es. Vous pouvez afficher des √©tats de chargement pour les donn√©es manquantes.
- Ensuite, r√©cup√©rez les donn√©es c√¥t√© client et affichez-les quand elles sont pr√™tes.

Cette approche fonctionne bien pour, par exemple, les pages de tableau de bord utilisateur. Parce qu'un tableau de bord est une page priv√©e et sp√©cifique √† l'utilisateur, le SEO n'est pas pertinent et la page n'a pas besoin d'√™tre pr√©-rendue. Les donn√©es sont mises √† jour fr√©quemment, ce qui n√©cessite une r√©cup√©ration de donn√©es au moment de la requ√™te.

## Pr√©-rendu avec des donn√©es par d√©faut [#pre-rendering-with-default-data]

Si la page doit √™tre pr√©-rendue, Next.js prend en charge [2 formes de pr√©-rendu](https://nextjs.org/docs/basic-features/data-fetching) :
**G√©n√©ration statique (SSG)** et **Rendu c√¥t√© serveur (SSR)**.

Ensemble avec SWR, vous pouvez pr√©-rendre la page pour le SEO, et aussi avoir des fonctionnalit√©s telles que le cache, la r√©validation, le suivi du focus, le rechargement sur intervalle c√¥t√© client.

Vous pouvez utiliser l'option `fallback` de [`SWRConfig`](/docs/global-configuration) pour passer les donn√©es pr√©charg√©es comme valeur initiale de tous les hooks SWR.
Comme exemple avec `getStaticProps`:

```jsx
 export async function getStaticProps () {
  // `getStaticProps` est ex√©cut√© c√¥t√© serveur.
  const article = await getArticleFromAPI()
  return {
    props: {
      fallback: {
        '/api/article': article
      }
    }
  }
}

function Article() {
  // `data` sera toujours disponible car il est dans `fallback`.
  const { data } = useSWR('/api/article', fetcher)
  return <h1>{data.title}</h1>
}

export default function Page({ fallback }) {
  // Les hooks SWR √† l'int√©rieur de la balise `SWRConfig` utiliseront ces valeurs.
  return (
    <SWRConfig value={{ fallback }}>
      <Article />
    </SWRConfig>
  )
}
```

La page est toujours pr√©-rendue. C'est SEO friendly, rapide √† r√©pondre, mais aussi enti√®rement aliment√© par SWR c√¥t√© client. Les donn√©es peuvent √™tre dynamiques et se mettre √† jour d'elles-m√™mes au fil du temps.

<Callout emoji="üí°">
  Le composant `Article` rendra d'abord les donn√©es pr√©-g√©n√©r√©es, et apr√®s que la page soit hydrat√©e, il r√©cup√©rera √† nouveau les derni√®res donn√©es pour les garder √† jour.
</Callout>

### Cl√© Complexes [#complex-keys]

`useSWR` peut √™tre utilis√© avec des cl√©s de type `array` et `function`. L'utilisation de donn√©es pr√©charg√©es avec ces types de cl√©s n√©cessite la s√©rialisation des cl√©s `fallback` avec `unstable_serialize`.

```jsx
import useSWR, { unstable_serialize } from 'swr'

export async function getStaticProps () {
  const article = await getArticleFromAPI(1)
  return {
    props: {
      fallback: {
        // unstable_serialize() du tableau de cl√©s
        [unstable_serialize(['api', 'article', 1])]: article,
      }
    }
  }
}

function Article() {
  // utilisation un tableau pour la cl√©
  const { data } = useSWR(['api', 'article', 1], fetcher)
  return <h1>{data.title}</h1>
}

export default function Page({ fallback }) {
  return (
    <SWRConfig value={{ fallback }}>
      <Article />
    </SWRConfig>
  )
}
```
