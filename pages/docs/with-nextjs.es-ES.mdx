import { Callout } from 'nextra-theme-docs'

# Uso con Next.js

## App Router [#app-dir]

### Server Components [#rsc]

<Callout type="default" emoji="‚úÖ">
   In Next.js App Router, all components are React Server Components (RSC) by default. **You could only import the key serialization APIs from SWR in RSC.**
</Callout>

```tsx filename="app/page.tsx" copy
import { unstable_serialize } from 'swr' // ‚úÖ works 
import { unstable_serialize as infinite_unstable_serialize } from 'swr/infinite' // ‚úÖ works 
```


<Callout type="error">
   You could not import any other APIs from SWR since they are not available in RSC.
</Callout>

```tsx filename="app/page.tsx" highlight={1}
import useSWR from 'swr' // ‚ùå it will throw an error
```

### Client Components

You need to mark your components with `'use client'` directive so that SWR could work properly.

```tsx filename="app/page.tsx" highlight={1} copy
'use client'
import useSWR from 'swr'
export default Page() {
  const { data } = useSWR('/api/user', fetcher)
  return <h1>{data.name}</h1>
}
```

If you need to use `SWRConfig` to do some global setup in your `layout` or `page` component, but you also don't want to make them client components. You could create a separate provider component.

```tsx filename="app/swr-provider.tsx" copy
'use client';
import { SWRConfig } from 'swr'
export const SWRProvider = ({ children }) => {
  return <SWRConfig>{children}</SWRConfig>
};
```

```tsx filename="app/page.tsx" copy
// This is still a server component
import { SWRProvider } from './swr-provider'
export default Page() {
  return (
    <SWRProvider>
      <h1>hello SWR</h1>
    </SWRProvider>
  )
}
```

## Obtenci√≥n de datos del lado del cliente [#client-side-data-fetching]

Si su p√°gina contiene datos que son actualizados frecuentemente y no necesita renderizar previamente los datos, SWR se adapta perfectamente y no se necesita una configuraci√≥n especial: solo importe `useSWR` y use el hook dentro de cualquier componente que use los datos.

As√≠ es como funciona:

- En primer lugar, muestre inmediatamente la p√°gina sin datos. Puede mostrar un loading state para los datos que faltan.

- A continuaci√≥n, se obtienen los datos en el lado del cliente y se muestran cuando est√°n listos.

Este enfoque funciona bien, por ejemplo, para p√°ginas que son dashboard. Dado que un dashboard es una p√°gina privada y espec√≠fica del usuario, el SEO no es relevante y la p√°gina no necesita ser pre-renderizado. Los datos se actualizan con frecuencia, lo que requiere la obtenci√≥n de datos en el momento de la solicitud.

## Pre-rendering with Default Data [#pre-rendering-with-default-data]

If the page must be pre-rendered, Next.js supports [2 forms of pre-rendering](https://nextjs.org/docs/basic-features/data-fetching):  
**Static Generation (SSG)** and **Server-side Rendering (SSR)**.

Together with SWR, you can pre-render the page for SEO, and also have features such as caching, revalidation, focus tracking, refetching on interval on the client side.

You can use the `fallback` option of [`SWRConfig`](/docs/global-configuration) to pass the pre-fetched data as the initial value of all SWR hooks. 
For example with `getStaticProps`:

```jsx
 export async function getStaticProps () {
  // `getStaticProps` is executed on the server side.
  const article = await getArticleFromAPI()
  return {
    props: {
      fallback: {
        '/api/article': article
      }
    }
  }
}

function Article() {
  // `data` will always be available as it's in `fallback`.
  const { data } = useSWR('/api/article', fetcher)
  return <h1>{data.title}</h1>
}

export default function Page({ fallback }) {
  // SWR hooks inside the `SWRConfig` boundary will use those values.
  return (
    <SWRConfig value={{ fallback }}>
      <Article />
    </SWRConfig>
  )
}
```

The page is still pre-rendered. It's SEO friendly, fast to response, but also fully powered by SWR on the client side. The data can be dynamic and self-updated over time.

<Callout emoji="üí°">
  The `Article` component will render the pre-generated data first, and after the page is hydrated, it will fetch the latest data again to keep it refresh.
</Callout>

### Complex Keys [#complex-keys]

`useSWR` can be used with keys that are `array` and `function` types. Utilizing pre-fetched data with these kinds of keys requires serializing the `fallback` keys with `unstable_serialize`.

```jsx
import useSWR, { unstable_serialize } from 'swr'

export async function getStaticProps () {
  const article = await getArticleFromAPI(1)
  return {
    props: {
      fallback: {
        // unstable_serialize() array style key
        [unstable_serialize(['api', 'article', 1])]: article,
      }
    }
  }
}

function Article() {
  // using an array style key.
  const { data } = useSWR(['api', 'article', 1], fetcher)
  return <h1>{data.title}</h1>
}

export default function Page({ fallback }) {
  return (
    <SWRConfig value={{ fallback }}>
      <Article />
    </SWRConfig>
  )
}
```
