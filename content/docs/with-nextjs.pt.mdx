---
title: 'Usando com Next.js'
---

## App Router [#app-dir]

### Server Components [#rsc]

<Callout type="default" emoji="‚úÖ">
   No App Router do Next.js, todos os componentes s√£o React Server Components (RSC) por padr√£o. **Voc√™ s√≥ pode importar as APIs de serializa√ß√£o de chave do SWR em RSCs.**
</Callout>

```tsx filename="app/page.tsx" copy
import { unstable_serialize } from 'swr' // ‚úÖ Dispon√≠vel em server components
import { unstable_serialize as infinite_unstable_serialize } from 'swr/infinite' // ‚úÖ Dispon√≠vel em server components

import { SWRConfig } from 'swr' // ‚úÖ Dispon√≠vel em server components
```

<Callout type="error">
   Voc√™ n√£o pode importar hook APIs do SWR, pois elas n√£o est√£o dispon√≠veis em RSCs.
</Callout>

```tsx filename="app/page.tsx" highlight={1}
import useSWR from 'swr' // ‚ùå Isso n√£o est√° dispon√≠vel em components
import useSWRInfinite from 'swr/infinite' // ‚ùå Isso n√£o est√° dispon√≠vel em components
import useSWRMutation from 'swr/mutation' // ‚ùå Isso n√£o est√° dispon√≠vel em components
```

### Client Components

Voc√™ pode marcar seus componentes com a diretiva `'use client'` ou importar o SWR de componentes do cliente, ambos os caminhos permitir√£o que voc√™ use os hooks de busca de dados do cliente SWR.

```tsx filename="app/page.tsx" highlight={1} copy
'use client'

import useSWR from 'swr'

export default function Page() {
  const { data } = useSWR('/api/user', fetcher)
  return <h1>{data.name}</h1>
}
```

### Buscar Dados Antecipadamente em Server Components

Similar ao padr√£o de [pr√©-renderiza√ß√£o com dados padr√£o](#pre-rendering-with-default-data), com React Server Components (RSC) voc√™ pode ir ainda mais longe.

Voc√™ pode __iniciar__ a busca antecipada de dados no lado do servidor e passar a __promise__ para a √°rvore de componentes do cliente atrav√©s da op√ß√£o `fallback` do provider `<SWRConfig>`:

```tsx filename="app/layout.tsx" copy
import { SWRConfig } from 'swr'

export default async function Layout({ children }: { children: React.ReactNode }) {
  // Inicie a busca de dados no lado do servidor.
  const userPromise = fetchUserFromAPI()
  const postsPromise = fetchPostsFromAPI()

  return (
    <SWRConfig
      value={{
        fallback: {
          // Passe as promises para os componentes do cliente.
          '/api/user': userPromise,
          '/api/posts': postsPromise,
        },
      }}
    >
      {children}
    </SWRConfig>
  )
}
```

<Callout emoji="üí°">
  As duas chamadas de fun√ß√£o de busca de dados `fetchUserFromAPI()` e `fetchPostsFromAPI()` ser√£o executadas em paralelo no lado do servidor porque n√£o as aguardamos imediatamente.
</Callout>

Em React Server Components, voc√™ pode passar promises atrav√©s da fronteira `"use client"`, e o SWR ir√° resolv√™-las automaticamente durante o Server-Side Rendering:

```tsx filename="app/page.tsx" copy
'use client'

import useSWR from 'swr'

export default function Page() {
  // O SWR resolver√° a promise passada dos componentes do servidor.
  // Tanto `user` quanto `posts` estar√£o prontos durante SSR e hidrata√ß√£o do cliente.
  const { data: user } = useSWR('/api/user', fetcher)
  const { data: posts } = useSWR('/api/posts', fetcher)

  return (
    <div>
      <h1>{user.name}'s Posts</h1>
      <ul>
        {posts.map(post => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  )
}
```

Ent√£o, no lado do cliente, o SWR assumir√° o controle e manter√° o comportamento normal.

Ao passar promises dos Server Components para Client Components, a busca de dados pode ser iniciada o mais cedo poss√≠vel no lado do servidor. E apenas os limites de UI (fronteira `Suspense` mais pr√≥xima ou layout Next.js) que realmente consomem os dados ser√£o bloqueados durante o SSR de streaming.

## Obtendo dados em Client-side [#client-side-data-fetching]

Se a sua p√°gina cont√©m dados que atualizam frequentemente, e voc√™ n√£o precisa pr√©-renderizar os dados, o SWR √© perfeito e n√£o precisa de configura√ß√£o especial: apenas importe o `useSWR` e use o hook dentro de qualquer componente que use os dados.

Funciona assim:

- Primeiro, imediatamente mostre a p√°gina sem dados. Voc√™ pode mostrar estados de carregamento para dados que est√£o faltando.
- Ent√£o, busque os dados no lado do cliente e exiba-os quando estiver pronto.

Essa estrat√©gia funciona bem para p√°ginas de dashboard de usu√°rio, por exemplo. Como a p√°gina do dashboard √© uma p√°gina privada e espec√≠fica do usu√°rio, o SEO n√£o √© relevante e a p√°gina n√£o precisa ser pr√©-renderizada.
Os dados s√£o atualizados com frequ√™ncia, o que requer a busca de dados no momento da solicita√ß√£o.

## Pr√©-rendedrizando com dados padr√£o [#pre-rendering-with-default-data]

Se a p√°gina precisa ser pr√©-renderizada, o Next.js suporta [2 formas de pr√©-renderiza√ß√£o](https://nextjs.org/docs/basic-features/data-fetching):
**Gera√ß√£o Est√°tica (SSG)** e **Renderiza√ß√£o Server-side (SSR)**.

Junto com o SWR, voc√™ pode pr√©-renderizar a p√°gina para SEO e tamb√©m ter recursos como cache, revalida√ß√£o, rastreamento de foco, refetching em intervalo no lado do cliente.

Voc√™ pode usar a op√ß√£o `fallback` de [`SWRConfig`](/docs/global-configuration) para passar os dados pr√©-buscados como o valor inicial de todos os hooks SWR.

Por exemplo, com o `getStaticProps`:

```jsx
 export async function getStaticProps () {
  // `getStaticProps` √© executado no lado do servidor.
  const article = await getArticleFromAPI()
  return {
    props: {
      fallback: {
        '/api/article': article
      }
    }
  }
}

function Article() {
  // `data` estar√° sempre dispon√≠vel, pois est√° em `fallback`.
  const { data } = useSWR('/api/article', fetcher)
  return <h1>{data.title}</h1>
}

export default function Page({ fallback }) {
  // Hooks SWR dentro do limites do `SWRConfig` usar√£o esses valores.
  return (
    <SWRConfig value={{ fallback }}>
      <Article />
    </SWRConfig>
  )
}
```

A p√°gina ainda √© pr√©-renderizada. √â amig√°vel para SEO, r√°pida para responder, mas tamb√©m totalmente alimentada pelo SWR no lado do cliente. Os dados podem ser din√¢micos e atualizados automaticamente ao longo do tempo.

<Callout emoji="üí°">
  O componente `Article` ir√° renderizar os dados pr√©-gerados primeiro e, ap√≥s a p√°gina ser hidratada, ele buscar√° novamente os dados mais recentes para mant√™-los atualizados.
</Callout>

### Chaves Complexas [#complex-keys]

`useSWR` podem ser usadas com chaves que s√£o do tipo `array` ou `function`. Utilizar dados pr√©-obtidos com esses tipos de chaves requer serializar as chaves `fallback` usando o `unstable_serialize`.

```jsx
import useSWR, { unstable_serialize } from 'swr'

export async function getStaticProps () {
  const article = await getArticleFromAPI(1)
  return {
    props: {
      fallback: {
        // chave de lista usando unstable_serialize()
        [unstable_serialize(['api', 'article', 1])]: article,
      }
    }
  }
}

function Article() {
  // usando uma chave de estilo de array.
  const { data } = useSWR(['api', 'article', 1], fetcher)
  return <h1>{data.title}</h1>
}

export default function Page({ fallback }) {
  return (
    <SWRConfig value={{ fallback }}>
      <Article />
    </SWRConfig>
  )
}
```
